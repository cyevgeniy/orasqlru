<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Основы PL/SQL on Учебник Oracle SQL, PL/SQL</title><link>http://orasql.ru/plsql/basics/</link><description>Recent content in Основы PL/SQL on Учебник Oracle SQL, PL/SQL</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="http://orasql.ru/plsql/basics/index.xml" rel="self" type="application/rss+xml"/><item><title>Анонимные блоки</title><link>http://orasql.ru/plsql/basics/plsql_anonymous_blocks/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/plsql/basics/plsql_anonymous_blocks/</guid><description>Любой PL/SQL код, состоит из блоков. Для начала рассмотрим анонимные блоки. Их структура следующая:
DECLARE BEGIN END; Секция объявления переменных является необязательной и может отсутствовать. В таком случае анонимный блок представляет собой блок вида:
BEGIN END;</description></item><item><title>Вложенные и именованные блоки</title><link>http://orasql.ru/plsql/basics/plsql_blocks/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/plsql/basics/plsql_blocks/</guid><description>В прошлый раз был рассмотрен самый простой вариант блоков в PL/SQL - анонимные блоки.
В этой части мы рассмотрим возможность вкладывать блоки внутрь других блоков, а также давать блокам имена.
Вложенные блоки declare l_a number := 10; begin -- Начало вложенного блока declare l_b number; begin l_b := 20; dbms_output.put_line(l_a); dbms_output.put_line(l_b); end; end; / Вложенные блоки могут обращаться ко всем объектам, которые были объявлены во внешних блоках. Именно поэтому в примере выше мы свободно можем обращаться из к переменной l_a, которая была объявлена во внешнем блоке.</description></item><item><title>Первая программа на PL/SQL</title><link>http://orasql.ru/plsql/basics/plsql_first_program/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/plsql/basics/plsql_first_program/</guid><description>Итак, напишем нашу первую программу на PL/SQL. Но перед этим создадим простую таблицу users, в которой будем хранить список пользователей некой системы:
create table users( id number primary key, login varchar2(60) not null, sign_date date default sysdate not null, is_active number(1) default 1 not null ); insert into users values(1, 'UserA', to_date('21.01.2019', 'dd.mm.yyyy'), 1); insert into users values(2, 'UserB', to_date('15.07.2017', 'dd.mm.yyyy'), 1); insert into users values(3, 'UserC', to_date('02.10.2015', 'dd.mm.yyyy'), 1); Теперь приведем текст программы:</description></item><item><title>DBMS_OUTPUT.PUT_LINE. Вывод на экран</title><link>http://orasql.ru/plsql/basics/plsql_dbms_put_line/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/plsql/basics/plsql_dbms_put_line/</guid><description>При изучении любого языка программирования очень важно иметь возможность выводить информацию на экран.
Несмотря на то, что PL/SQL - язык, интегрированный в БД Oracle, он также имеет возможность вывода информации на экран. Для этого используется процедура dbms_output.put_line.
Пример вызова:
begin dbms_output.put_line('Hello, World'); dbms_output.put_line(23); dbms_output.put_line('Hello, ' || 'World'); dbms_output.put_line(sysdate); end; / Вывод программы:
Hello, World 23 Hello, World 29-AUG-21 Как видно из примера, dbms_output.put_line позволяет выводить строки, числа и даты - основные типы в Oracle.</description></item><item><title>Переменные, константы. Простые типы данных</title><link>http://orasql.ru/plsql/basics/plsql_simpletypes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/plsql/basics/plsql_simpletypes/</guid><description>Рассмотрим типы, которые позволяют хранить три сущности - числа, строки и даты.
Числа Тип для хранения чисел в PL/SQL используется тот же тип данных, что и при создании таблиц. Почитать про него можно здесь.
Существуют и другие типы для работы с числами, например PLS_INTEGER, SIMPLE_INTEGER и др. Они будут рассмотрены позже.
Даты Для дат используются те же типы, что и в SQL - Date и Timestamp.
Строки Для хранения строк используются типы Varchar2 и CLOB.</description></item><item><title>Условное ветвление. If...else...elsif</title><link>http://orasql.ru/plsql/basics/plsql_ifelse/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/plsql/basics/plsql_ifelse/</guid><description>Условное ветвление используется тогда, когда нужно выполнить разные действия в зависимости от условий. Для этого в PL/SQL используется конструкция if.
If declare l_name varchar2(100) := 'Admin'; begin if l_name = 'Admin' then dbms_output.put_line('User is Admin'); end if; end; / В примере выше описан простейший вариант использования if. Если имя пользователя равно строке &amp;ldquo;Admin&amp;rdquo;, мы выводим соответствующее сообщение.
В конструкции If может быть несколько условий:
declare l_name varchar2(100) := 'Admin'; begin if l_name = 'Admin' or l_name = 'TempAdmin' then dbms_output.</description></item><item><title>Схема БД. Её объекты</title><link>http://orasql.ru/plsql/basics/plsql_schema/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/plsql/basics/plsql_schema/</guid><description>Понятие схемы БД Схема - это совокупность всех объектов некоего пользователя, называемого владельцем схемы. Сюда входят таблицы, индексы, представления, триггеры, всё-всё-всё. То есть мы должны понимать, что когда мы говорим про функции или процедуры в PL/SQL, они находятся внутри схемы.
Мы не будем перечислять все возможные типы объектов, которые могут храниться в схеме, перечислим лишь несколько. Все нижеописанные объекты будут рассмотрены по отдельности далее в учебнике, здесь будет дана информация для первичного ознакомления с ними.</description></item><item><title>Функции в PL/SQL</title><link>http://orasql.ru/plsql/basics/plsql_functions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/plsql/basics/plsql_functions/</guid><description>Какую проблему помогают решить функции Общее описание функций уже было дано в предыдущей части, добавим лишь то, что функции - это один из способов сделать наш код более простым, понятным, компактным, а также избежать повторного написания однотипного кода.
Пример создания простой функции Предположим, что мы работаем над системой, в которой часто приходится считать размер скидок в зависимости от стоимости купленного товара. Размер скидки интересует нас с точностью до двух знаков после запятой.</description></item><item><title>Процедуры в PL/SQL</title><link>http://orasql.ru/plsql/basics/plsql_procedures/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/plsql/basics/plsql_procedures/</guid><description>Пример создания простой процедуры create or replace procedure validate_age( page number ) is begin if page &amp;lt; 18 then dbms_output.put_line('Вам должно быть 18 или больше'); else dbms_output.put_line('Всё хорошо'); end if; end; Вызовем процедуру c несколькими параметрами:
begin validate_age(17); validate_age(40); end; / Вывод:
Вам должно быть 18 или больше Всё хорошо Как видно, особых отличий от создания функций нет. Основное отличие - процедуры не возвращают значений в таком виде, как это делают функции (через вызов return).</description></item><item><title>Взаимодействие PL/SQL и SQL. Переключение контекста</title><link>http://orasql.ru/plsql/basics/context/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/plsql/basics/context/</guid><description>Движки SQL и PL/SQL Когда Oracle получает команду выполнить какой-либо SQL запрос, он передаёт эту работу SQL движку. Следует взять за правило, что SQL движок является более быстрым, чем PL/SQL движок - все его функции встроены в ядро БД и написаны на языке C. Это основной язык для работы с данными в БД, он лучше оптимизирован. PL/SQL код, в свою очередь, выполняется PL/SQL движком. Он добавляет возможность процедурного программирования, но, в свою очередь, он медленнее, чем SQL, несмотря на то, что в Oracle постоянно работают над его улучшением.</description></item></channel></rss>