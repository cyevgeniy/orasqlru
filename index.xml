<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Учебник Oracle SQL, PL/SQL</title><link>http://orasql.ru/</link><description>Recent content on Учебник Oracle SQL, PL/SQL</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="http://orasql.ru/index.xml" rel="self" type="application/rss+xml"/><item><title>Анонимные блоки</title><link>http://orasql.ru/plsql/basics/plsql_anonymous_blocks/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/plsql/basics/plsql_anonymous_blocks/</guid><description>Любой PL/SQL код, состоит из блоков. Для начала рассмотрим анонимные блоки. Их структура следующая:
DECLARE BEGIN END; Секция объявления переменных является необязательной и может отсутствовать. В таком случае анонимный блок представляет собой блок вида:
BEGIN END;</description></item><item><title>Введение в SQL</title><link>http://orasql.ru/sql/intro/sqlintro/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/sql/intro/sqlintro/</guid><description>SQL, или Structure Query Language (Структурированный язык запросов) является основным инструментом для взаимодействия с реляционными базами данных.
С помощью sql можно:
Получать данные из базы данных Сохранять данные в базу данных Производить манипуляции с объектами базы данных Диалекты SQL Реляционных систем управления базой данных(СУБД) существует достаточно много. И как правило, в каждой СУБД есть свои отличительные особенности в SQL, которые заключаются в наличии или отсутствии в нем определенных функций, различиях синтаксиса самого SQL, а также по функциональным возможностям этого языка.</description></item><item><title>Объединение. UNION</title><link>http://orasql.ru/sql/sets/unions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/sql/sets/unions/</guid><description>Предположим, что у нас есть 2 таблицы - таблица учителей teachers и таблица учеников students:
create table teachers( id number primary key, first_name varchar2(50) not null, last_name varchar2(100) ); create table students( id number primary key, first_name varchar2(50) not null, last_name varchar2(100), group_id number ); insert into teachers values (1, 'Галина', 'Иванова'); insert into teachers values (2, 'Нина', 'Сидорова'); insert into teachers values (3, 'Евгения', 'Петрова'); insert into students values (1, 'Александр', 'Обломов', 1); insert into students values (2, 'Николай', 'Рудин', 2); insert into students values (3, 'Евгения', 'Петрова', 1); Перед нами стоит задача - нужно отобразить единым списком учителей и учеников.</description></item><item><title>Оператор INSERT</title><link>http://orasql.ru/sql/dml/dmlinsert/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/sql/dml/dmlinsert/</guid><description>Как уже говорилось ранее, INSERT предназначен для вставки данных в таблицу. Существует несколько вариантов его использования.
Вставка с указанием колонок В таком варианте после указания таблицы в скобках перечисляются колонки, в которые будут записываться указываемые данные.
insert into employees(id, name, age) values(1, 'John', 35) Данный способ является предпочтительным, т.к. он более информативен - сразу видно, что за данные вставляются в таблицу.
Также, при использовании такого способа, можно изменять порядок перечисления данных для строки:</description></item><item><title>Первичные ключи</title><link>http://orasql.ru/sql/dbobjects/primarykeys/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/sql/dbobjects/primarykeys/</guid><description>Рассмотрим следующую ситуацию: пусть у нас есть 2 таблицы. Первая содержит список сотрудников, вторая - размер бонусов к зарплате для какой-то части этих сотрудников.
В жизни есть определенная вероятность того, что двух разных людей могут звать одинаково. Так вышло и у нас - 2 абсолютно разных сотрудника имеют одинаковое имя - &amp;ldquo;Алексей Иванов&amp;rdquo;.
Предположим, что мы хотим одному из них начислить бонус в размере 200$. Глядя на список сотрудников с бонусами, можем ли мы сказать, какому именно Алексею Иванову мы должны начислить бонус в размере 200$?</description></item><item><title>Таблицы</title><link>http://orasql.ru/sql/basics/tables/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/sql/basics/tables/</guid><description>Данные в реляционных базах данных хранятся в таблицах. Таблицы - это ключевой объект, с которыми придется работать в SQL.
Таблицы в БД совсем не отличаются от тех таблиц, с которыми все уже знакомы со школы - они состоят из колонок и строк.
Каждая колонка в таблице имеет своё имя и свой тип, т.е. тип данных, которые будут в ней содержаться. Помимо типа данных для колонки можно указать максимальный размер данных, которые могут содержаться в этой таблице.</description></item><item><title>Транзакции в Oracle</title><link>http://orasql.ru/sql/transactions/transactions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/sql/transactions/transactions/</guid><description>Что такое транзакции Транзакции - это набор изменений данных, хранящихся в БД, который должен быть либо выполнен, либо отменен. До сих пор все примеры учебника, которые изменяли данные, как правило состояли из одного запроса, и все наши транзакции состояли из одного запроса. Если вы пользовались сервисом LiveSql, как мы рекомендовали, то беспокоиться о транзакциях не следовало. На самом деле, о них можно было не беспокоиться и в том случае, если примеры запускались для локально установленной БД Oracle, просто все изменения после закрытия соединения не были применены.</description></item><item><title>Функции для работы со строками</title><link>http://orasql.ru/sql/standfunc/stringfunctions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/sql/standfunc/stringfunctions/</guid><description>Создадим тестовую таблицу.
create table articles( title varchar2(50) not null, author varchar2(50) not null, msg varchar2(300) not null, publish_date date not null ); comment on table articles is 'Твиты'; comment on column articles.title is 'Заголовок'; comment on column articles.author is 'Автор'; comment on column articles.msg is 'Сообщение'; insert into articles values ('Новый фотоаппарат!', 'johndoe', 'Сегодня купил себе новый фотоаппарат. Надеюсь, у меня будут получаться отличные фотографии!', sysdate); insert into articles values ('Насобирал денег', 'johndoe', 'Целый год я шел к этой цели, и вот наконец-то у меня все получилось, и заветная сумма собрана!</description></item><item><title>Что такое PL/SQL</title><link>http://orasql.ru/plsql/intro/plsql_intro/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/plsql/intro/plsql_intro/</guid><description>PL/SQL - императивный язык программирования, интегрированный в БД &amp;ldquo;Oracle&amp;rdquo;. Он дает возможность:
Создавать хранимые процедуры и функции Использовать конструкции, характерные для императивных языков программирования: ветвление, циклы, обработка исключений и др. Особенности Пожалуй, самой отличительной особенностью является его тесная интеграция с БД &amp;ldquo;Oracle&amp;rdquo; и языком SQL. PL/SQL может работать только внутри БД &amp;ldquo;Oracle&amp;rdquo; и не может быть использован за её пределами.
Язык поддерживает процедурный и объектно-ориентированный(в его современном понимании) подходы.</description></item><item><title>DML, DDL</title><link>http://orasql.ru/sql/intro/ddldml/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/sql/intro/ddldml/</guid><description>Команды языка SQL можно разбить на две группы - DML и DDL.
Кроме DML и DDL существуют еще команды DCL и TCL. На текущий момент они не рассматриваются в этом учебнике.
DML расшифровывается как Data Manipulation Language (Язык манипулирования данными). В него входят те команды SQL, которые могут изменять уже имеющиеся данные в БД. Под изменением следует понимать также добавление новой информации в БД и удаление уже существующей.
К командам DML относятся:</description></item><item><title>Вложенные и именованные блоки</title><link>http://orasql.ru/plsql/basics/plsql_blocks/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/plsql/basics/plsql_blocks/</guid><description>В прошлый раз был рассмотрен самый простой вариант блоков в PL/SQL - анонимные блоки.
В этой части мы рассмотрим возможность вкладывать блоки внутрь других блоков, а также давать блокам имена.
Вложенные блоки declare l_a number := 10; begin -- Начало вложенного блока declare l_b number; begin l_b := 20; dbms_output.put_line(l_a); dbms_output.put_line(l_b); end; end; / Вложенные блоки могут обращаться ко всем объектам, которые были объявлены во внешних блоках. Именно поэтому в примере выше мы свободно можем обращаться из к переменной l_a, которая была объявлена во внешнем блоке.</description></item><item><title>Внешние ключи</title><link>http://orasql.ru/sql/dbobjects/foreignkeys/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/sql/dbobjects/foreignkeys/</guid><description>Рассмотрим пример из части про первичные ключи.
У нас было две таблицы - список сотрудников и единовременные бонусы для них. С помощью первичного ключа в таблице сотрудников мы решили проблему соотношения между бонусами и сотрудниками.
Схематично наши таблицы выглядят вот так:
Благодаря наличию первичного ключа мы однозначно можем сказать, какому сотруднику какой бонус начисляется.
А теперь посмотрим на следующую ситуацию: в таблицу bonuses добавляется запись со значением emp_id, которому нет соответствия в таблице сотрудников.</description></item><item><title>Изменение данных. UPDATE</title><link>http://orasql.ru/sql/dml/dmlupdate/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/sql/dml/dmlupdate/</guid><description>Данный оператор изменяет уже существующие данные в таблице.
Общий синтаксис выглядит следующим образом:
UPDATE table_1 t SET t.column_1 = val_1, t.columm_2 = val_2 WHERE При обновлении можно ссылаться на текущие значения в таблице. Например, увеличим возраст всех сотрудников на 1 год:
update employees emp set emp.age = emp.age + 1 Можно добавлять любые условия в where, как и в select- запросах, чтобы обновить не все строки в таблице, а только те, которые удовлетворяют определенным условиям.</description></item><item><title>Когда использовать PL/SQL</title><link>http://orasql.ru/plsql/intro/plsql_whentouse/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/plsql/intro/plsql_whentouse/</guid><description>PL/SQL нужно использовать, когда:
Нужно скрыть функционал за общим интерфейсом(инкапсуляция) Возможностей SQL недостаточно Реализация на PL/SQL будет более сопровождаемой Коротко по каждому из пунктов.
Инкапсуляция Мы можем создать функцию, либо хранимую процедуру, после чего различные клиенты смогут воспользоваться ими, не зная деталей реализации функционала.
Недостаточно возможностей SQL Здесь лучше подойтет пример. Предположим, нам нужно реализовать логику:
Если значение некоего параметра, назовем его `quantity`, больше 100, то: Удалить некоторые строки из таблицы A.</description></item><item><title>Основные типы данных</title><link>http://orasql.ru/sql/basics/maintypes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/sql/basics/maintypes/</guid><description>Таблицы могут содержать не только строки. Рассмотрим основные типы данных в БД Oracle.
Varchar2 Строковый тип. При создании таблицы всегда нужно указывать размер строки. Размер может указываться в байтах либо в символах. По-умолчанию максимальный размер строки равен 4000 байт, либо 4000 символов. Этот размер может быть изменен дополнительной настройкой БД.
country(100);-- строка из 100 байт country(100 char); -- строка из 100 символов Number Числовой тип данных. Используется для хранения как целых чисел, так и дробных чисел.</description></item><item><title>Разница запросов. MINUS</title><link>http://orasql.ru/sql/sets/minus/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/sql/sets/minus/</guid><description>Подготовим тестовые данные:
create table cars( car_id number not null, car_model varchar2(100) not null, release_year number ); create table car_offers( car_model varchar2(100) not null, release_year number ); insert into cars values(1, 'Volkswagen passat', 1998); insert into cars values(2, 'Volkswagen passat', 1998); insert into cars values(3, 'Mersedes SL', 2010); insert into cars values(4, 'Lexus S300', 2005); insert into cars values(5, 'Mersedes SL', 2008); insert into car_offers values('Lexus S300', 2010); insert into car_offers values('Tesla', 2017); insert into car_offers values('Volkswagen passat', 1998); insert into car_offers values('Volkswagen passat', 2003); Посмотрим на данные в таблицах:</description></item><item><title>Функции для работы с NULL</title><link>http://orasql.ru/sql/standfunc/nullfunctions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/sql/standfunc/nullfunctions/</guid><description>Так как NULL - особое значение, то он удостоился отдельных функций в Oracle, которые умеют работать с ним &amp;ldquo;из коробки&amp;rdquo;.
Подготовка тестовых данных Работать будем со следующей таблицей:
create table profiles( login varchar2(30) primary key, last_updated date, status varchar2(50) ); comment on table profiles is 'Профили форума'; comment on column profiles.last_updated is 'Дата последнего обновления'; comment on column profiles.status is 'Статус'; insert into profiles(login, last_updated, status) values ('johndoe', to_date('01.01.2009 23:40', 'dd.</description></item><item><title>Выполнение SQL. Облачные сервисы</title><link>http://orasql.ru/sql/intro/sqlcloud/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/sql/intro/sqlcloud/</guid><description>Для того, чтобы начать работу с БД(причем любой), она должна быть где-либо установлена, и к ней должен быть доступ на подключение и выполнение запросов.
LiveSQL В этом учебнике для выполнения sql-запросов будет использоваться сервис Live SQL. Он позволяет выполнять SQL в облаке, что непременно большой плюс - там гораздо быстрее зарегистрироваться, чем скачивать, устанавливать и настраивать себе БД Oracle.
Работать с livesql очень просто; опишем стандартные шаги, необходимые для запуска своих sql-запросов.</description></item><item><title>Первая программа на PL/SQL</title><link>http://orasql.ru/plsql/basics/plsql_first_program/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/plsql/basics/plsql_first_program/</guid><description>Итак, напишем нашу первую программу на PL/SQL. Но перед этим создадим простую таблицу users, в которой будем хранить список пользователей некой системы:
create table users( id number primary key, login varchar2(60) not null, sign_date date default sysdate not null, is_active number(1) default 1 not null ); insert into users values(1, 'UserA', to_date('21.01.2019', 'dd.mm.yyyy'), 1); insert into users values(2, 'UserB', to_date('15.07.2017', 'dd.mm.yyyy'), 1); insert into users values(3, 'UserC', to_date('02.10.2015', 'dd.mm.yyyy'), 1); Теперь приведем текст программы:</description></item><item><title>Пересечение запросов</title><link>http://orasql.ru/sql/sets/intersect/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/sql/sets/intersect/</guid><description>В качестве тестовых данных будем использовать таблицы из примера про разность запросов.
Для получения пересечения данных между двумя запросами используется оператор INTERSECT. Он возвращает уникальные строки, которые присутствуют как в первом, так и во втором запросе.
Ограничения при использовании INTERSECT такие же, как и при использовании UNION и MINUS:
Оба запроса должны возвращать одинаковое количество колонок Типы данных в колонках должны совпадать. Получим список моделей автомобилей, которые есть и в автопарке, и в списке предлагаемых для покупки моделей:</description></item><item><title>Пример SELECT запроса</title><link>http://orasql.ru/sql/basics/selectstruct/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/sql/basics/selectstruct/</guid><description>Рассмотрим простой SQL запрос:
-- данные, которые мы извлекаем select emp.name, emp.last_name, emp.age, dept.name from employees emp join departments dept on dept.id = emp.department_id -- соединение where (emp.id = 10 and emp.age &amp;gt; 25) -- условие выборки order by name desc -- сортировка Конечно, запрос может выглядеть и по-другому, но в целом данный пример раскрывает большую часть из структуры SELECT запроса.
Порядок выполнения Очень важно понимать, в каком порядке выполняется запрос.</description></item><item><title>Удаление данных. DELETE</title><link>http://orasql.ru/sql/dml/dmldelete/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/sql/dml/dmldelete/</guid><description>Данный оператор предназначен для удаления строк из таблицы.
В самом простом варианте он используется для удаления всех данных из таблицы:
-- Удалить все данные из таблицы employees delete from employees Для удаления строк, попадающих под определенный критерий, как и в случае с оператором UPDATE, прописываем эти условия в WHERE части:
-- Удалить данные по сотруднику с id = 20 delete from employees emp where emp.id = 20; -- Удалить данные по сотрудникам старше 70 лет delete from employees emp where emp.</description></item><item><title>Уникальные ключи</title><link>http://orasql.ru/sql/dbobjects/uniquekeys/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/sql/dbobjects/uniquekeys/</guid><description>Возьмем нашу таблицу с сотрудниками и добавим туда колонку с номером паспорта сотрудника. Может ли у двух разных людей быть одинаковый номер паспорта? Однозначно нет. Если в наших данных возникнет такая ситуация, когда у нескольких сотрудников по ошибке указали один и тот же номер паспорта, это может обернуться серьезными ошибками - клиентская программа выдаст по поиску несколько записей вместо одной, либо вообще выдаст ошибку и закроется. Или в бухгалтерии переведут деньги не тому сотруднику, или наоборот, всем.</description></item><item><title>Условные функции</title><link>http://orasql.ru/sql/standfunc/conditional/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/sql/standfunc/conditional/</guid><description>Условные функции - это такие функции, которые могут возвращать разные результаты в зависимости от выполнения тех или иных условий.
В качестве тестовых данным будем использовать таблицу из части про функции для работы с NULL.
DECODE Функция DECODE в общем случае имеет следующий вид:
DECODE(что сравниваем, значение1, результат1, значение2, результат2, значение3, результат3, .... значениеN, результатN, значение по-умолчанию) Первым DECODE принимает параметр, значение которого будет сравниваться по очереди со списком значений, и в случае, когда он совпадет с одним из перечисленных, будет возвращен соответствующий результат.</description></item><item><title>DBMS_OUTPUT.PUT_LINE. Вывод на экран</title><link>http://orasql.ru/plsql/basics/plsql_dbms_put_line/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/plsql/basics/plsql_dbms_put_line/</guid><description>При изучении любого языка программирования очень важно иметь возможность выводить информацию на экран.
Несмотря на то, что PL/SQL - язык, интегрированный в БД Oracle, он также имеет возможность вывода информации на экран. Для этого используется процедура dbms_output.put_line.
Пример вызова:
begin dbms_output.put_line('Hello, World'); dbms_output.put_line(23); dbms_output.put_line('Hello, ' || 'World'); dbms_output.put_line(sysdate); end; / Вывод программы:
Hello, World 23 Hello, World 29-AUG-21 Как видно из примера, dbms_output.put_line позволяет выводить строки, числа и даты - основные типы в Oracle.</description></item><item><title>Битовые операции</title><link>http://orasql.ru/sql/standfunc/bit/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/sql/standfunc/bit/</guid><description>Битовые операции при работе с БД применяются редко. Тем не менее, работа с отдельными битами поддерживается в БД Oracle, и в некоторых случаях может быть использована в весьма элегантном виде.
Тестовые данные create table docs( id number not null primary key, doc_num varchar2(100 char) not null, bit_access number default 0 not null ); comment on table docs is 'Документы'; comment on column docs.bit_access is 'Уровни доступа(1 бит - чтение, 2 - редактирование, 3 - удаление)'; insert into docs values(1, '1-1', 0); insert into docs values(2, '2-1', 1); insert into docs values(3, '2-2', 4); insert into docs values(4, '3-1', 3); insert into docs values(5, '4-1', 7); Колонка bit_access хранит в себе число, каждый бит которого отвечает за наличие(1) или отсутствие(0) доступа на произведение операций с данной строкой таблицы(документом).</description></item><item><title>Инструменты для работы с БД Oracle</title><link>http://orasql.ru/sql/intro/instruments/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/sql/intro/instruments/</guid><description>Далее будут приведены ссылки на полезные инструменты, которые могут пригодиться для работы с Oracle.
Средства разработки Pl/sql developer - известная среда разработки для Oracle, платная, есть пробный период. SQL Developer бесплатная среда разработки от Oracle. Toad for Oracle DBForge studio for Oracle JetBrains Datagrip - отлично подходит, если необходимо работать одновременно с разными БД. Если рассматривать функционал, доступный с БД Oracle, то немного отстает от всех вышеперечисленных.</description></item><item><title>Написание SQL- кода</title><link>http://orasql.ru/sql/basics/scripts/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/sql/basics/scripts/</guid><description>Код SQL, как и любой другой, можно сохранять в файлы. Расширение этих файлов на самом деле не имеет значения, но принято сохранять sql-скрипты с расширением .sql.
Некоторые IDE могут сохранять SQL-код и с другими расширениями файлов(например PL/SQL Developer - для т.н. тестовых скриптов он использует расширение *.tst.
Комментарии В SQL можно и нужно добавлять комментарии. Это участки текста, предназначенные для чтения другими людьми, и которые не обрабатываются базой данных.
Комментарий может быть однострочным:</description></item><item><title>Представления</title><link>http://orasql.ru/sql/dbobjects/views/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/sql/dbobjects/views/</guid><description>Что такое представления Представления(Views) - это такой объект в БД, который:
Выглядит как таблица Внутри себя содержит SQL запрос, которым заменяется таблица при обращении к ней. Во многом представления работают также, как и обычные таблицы. В них можно(правда с определенными ограничениями) вставлять, изменять и удалять данные.
Создание представлений Общий синтаксис создания представления следующий:
create view viewname as select ... .... ....; Т.е. для создания представления достаточно написать запрос, который возвращать нужные данные.</description></item><item><title>Работа с множествами. Общая информация</title><link>http://orasql.ru/sql/sets/sets/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/sql/sets/sets/</guid><description>Следить за порядком колонок При использовании операторов UNION, MINUS и INTERSECT нужно внимательно следить за порядком колонок в каждом из запросов, ведь несоблюдение порядка следования приведет к некорректным результатам.
Как было рассмотрено, Oracle будет проверять, чтобы тип колонок в каждом из запросов совпадал, но проверять, правильно ли расположены колонки одного типа, он не будет (потому что не сможет).
select car_model model, car_id release_year from cars minus select car_model, release_year from car_offers В запросе выше, в первой его части, вместо колонки release_year по ошибке была указана колонка car_id.</description></item><item><title>Слияние данных. MERGE</title><link>http://orasql.ru/sql/dml/dmlmerge/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/sql/dml/dmlmerge/</guid><description>Команда MERGE позволяет выбрать строки из одного источника и использовать их для обновления, вставки или удаления строк в таблице.
Вся прелесть данной команды в том, что в некоторых она позволяет сделать все эти операции в одном выражении SQL.
Подготовка данных Будем использовать следующие таблицы:
create table employees( id number not null, emp_name varchar2(200 char) not null, department varchar2(100 char) not null, position varchar2(100 char) not null ); create table ted_speakers( emp_id number not null, room varchar2(30 char), conf_date date not null ); insert into employees values(1, 'Иван Иванов', 'SALARY', 'MANAGER'); insert into employees values(2, 'Елена Петрова', 'SALARY', 'CLERK'); insert into employees values(3, 'Алексей Сидоров', 'IT', 'DEVELOPER'); insert into employees values(4, 'Михаил Иванов', 'IT', 'DEVELOPER'); insert into employees values(5, 'Владимир Петров', 'IT', 'QA'); insert into ted_speakers values(1, '201b', to_date('2020.</description></item><item><title>Агрегирующие функции</title><link>http://orasql.ru/sql/standfunc/aggregation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/sql/standfunc/aggregation/</guid><description>Агрегирующие функции - это такие функции, которые выполняются не для каждой строки отдельно, а для определенных групп данных.
Подготовка данных create table employees( id number not null, first_name varchar2(50 char) not null, last_name varchar2(100 char), bd date not null, job varchar2(100) ); insert into employees values(1, 'Василий', 'Петров', to_date('07.10.1990', 'dd.mm.yyyy'), 'Машинист'); insert into employees values(2, 'Александр', 'Сидоров', to_date('18.07.1980', 'dd.mm.yyyy'), 'Бухгалтер'); insert into employees values(3, 'Евгения', 'Цветочкина', to_date('18.07.1978', 'dd.mm.yyyy'), 'Бухгалтер'); insert into employees values(4, 'Владимир', 'Столяров', to_date('18.</description></item><item><title>Изменение структуры таблицы. ALTER TABLE</title><link>http://orasql.ru/sql/dml/dmlaltertable/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/sql/dml/dmlaltertable/</guid><description>Уже созданные таблицы можно изменять. Для этого используется команда SQL ALTER. Данная команда относится к группе DDL.
Подготовка данных Тестировать будем на таблице employees. Изначально она будет состоять только из одной колонки id:
create table employees( id number not null primary key ); insert into employees(id) values(1); insert into employees(id) values(2); insert into employees(id) values(3); insert into employees(id) values(4); Добавление колонки в таблицу Добавим в таблицу сотрудников колонку для хранения дня рождения:</description></item><item><title>Индексы</title><link>http://orasql.ru/sql/dbobjects/indexes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/sql/dbobjects/indexes/</guid><description>Что такое индексы Индексы - это специальные объекты в БД, которые хранят в себе записи для каждого встречающегося в индексированной колонке значения. Внутреннее устройство индексов таково, что они позволяют быстро находить строки в таблице, содержащие определенные значения.
Чтобы лучше понять как работает индекс и для чего он нужен, представьте телефонный справочник, в котором абоненты расположены в случайном порядке. Чтобы найти нужного абонента, придется просматривать все записи в справочнике по порядку до тех пор, пока не встретится нужный.</description></item><item><title>Переменные, константы. Простые типы данных</title><link>http://orasql.ru/plsql/basics/plsql_simpletypes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/plsql/basics/plsql_simpletypes/</guid><description>Рассмотрим типы, которые позволяют хранить три сущности - числа, строки и даты.
Числа Тип для хранения чисел в PL/SQL используется тот же тип данных, что и при создании таблиц. Почитать про него можно здесь.
Существуют и другие типы для работы с числами, например PLS_INTEGER, SIMPLE_INTEGER и др. Они будут рассмотрены позже.
Даты Для дат используются те же типы, что и в SQL - Date и Timestamp.
Строки Для хранения строк используются типы Varchar2 и CLOB.</description></item><item><title>Сортировка результатов. Order by</title><link>http://orasql.ru/sql/basics/orderby/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/sql/basics/orderby/</guid><description>При выборке данных из БД мы можем сортировать извлекаемые данные в нужном нам порядке. Использование сортировки поможет сделать получаемые данные более удобочитаемыми и воспринимаемыми для анализа человеком.
Подготовка тестовых данных Создадим таблицу, которая будет содержать список блюд ресторана:
create table dishes( name varchar2(100) not null, price number(5,2) not null, rating number(5) ); comment on column dishes.name is 'Наименование блюда'; comment on column dishes.price is 'Стоимость за одну порцию'; comment on column dishes.</description></item><item><title>Ссылки на полезные ресурсы</title><link>http://orasql.ru/sql/intro/links/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/sql/intro/links/</guid><description>Примечание: Все приведённые ниже ресурсы - англоязычные.
Youtube Practically Perfect PL/SQL The Magic of SQL Connor McDonald Oracle Developers Блоги/сайты Ask Tom https://connor-mcdonald.com/ https://stevenfeuersteinonplsql.blogspot.com/ https://oracle-base.com https://blogs.oracle.com/sql/ http://www.dba-oracle.com Книги Книг написано достаточно много, и нет смысла их перечислять. Единственное, что можно порекомендовать — по возможности читайте англоязычные книги, так как русскоязычные переводы могут быть с ошибками.</description></item><item><title>Виртуальные колонки</title><link>http://orasql.ru/sql/dbobjects/virtualcolumns/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/sql/dbobjects/virtualcolumns/</guid><description>Создание виртуальных колонок Виртуальные колонки были добавлены в 11 версии Oracle.
Виртуальные колонки - это колонки, которые вычисляются на основе других колонок таблицы. Например:
create table cars( id number primary key, model varchar2(100) not null, engine_volume number, max_speed_km number not null, max_speed_ml generated always as (max_speed_km / 1.609)); comment on column cars.max_speed_km is 'Максимальная скорость, км/ч'; comment on column cars.max_speed_ml is 'Максимальная скорость, миль/ч'; Здесь максимальная скорость в милях вычисляется на основании данных о максимальной скорости автомобиля в километрах.</description></item><item><title>Оператор WHERE. Операторы сравнения</title><link>http://orasql.ru/sql/basics/comparison/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/sql/basics/comparison/</guid><description>Использование оператора where позволяет добавить фильтр на те данные, которые будет обрабатывать sql, будь то выборка, вставка, обновление или удаление.
Для демонстрации будем использовать те же данные, что и в примере с order by :
create table dishes( name varchar2(100) not null, price number(5,2) not null, rating number(5) ); comment on column dishes.name is 'Наименование блюда'; comment on column dishes.price is 'Стоимость за одну порцию'; comment on column dishes.rating is 'Популярность блюда'; insert into dishes(name, price, rating) values ('Макароны с сыром', 20.</description></item><item><title>Работа с датами в Oracle</title><link>http://orasql.ru/sql/standfunc/datefunctions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/sql/standfunc/datefunctions/</guid><description>В БД Oracle для работы с датами предназначены 2 типа - DATE и TIMESTAMP.
Отдельно можно упомянуть INTERVAL - интервальный тип, который хранит диапазон между двумя датами.
Тип DATE Тип DATE используется чаще всего, когда необходимо работать с датами в БД Oracle. Он позволяет хранить даты с точностью до секунд.
Некоторые БД, например MySQL, также имеют тип DATE, но там может храниться дата лишь с точностью до дня.
Приведение строки к дате Одна из часто встречающихся ситуаций - необходимость представить строку в виде типа данных DATE.</description></item><item><title>Условное ветвление. If...else...elsif</title><link>http://orasql.ru/plsql/basics/plsql_ifelse/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/plsql/basics/plsql_ifelse/</guid><description>Условное ветвление используется тогда, когда нужно выполнить разные действия в зависимости от условий. Для этого в PL/SQL используется конструкция if.
If declare l_name varchar2(100) := 'Admin'; begin if l_name = 'Admin' then dbms_output.put_line('User is Admin'); end if; end; / В примере выше описан простейший вариант использования if. Если имя пользователя равно строке &amp;ldquo;Admin&amp;rdquo;, мы выводим соответствующее сообщение.
В конструкции If может быть несколько условий:
declare l_name varchar2(100) := 'Admin'; begin if l_name = 'Admin' or l_name = 'TempAdmin' then dbms_output.</description></item><item><title>Аналитические функции</title><link>http://orasql.ru/sql/standfunc/analytics/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/sql/standfunc/analytics/</guid><description>Аналитические функции - очень мощный инструмент в SQL. Со слов Тома Кайта, можно написать отдельную книгу по аналитическим функциям, настолько они полезны.
Аналитические функции - это те же агрегирующие функции, но их главная особенность в том, что они работают без необходимости группировки строк.
Аналитические функции выполняются последними в запросе, поэтому они могут быть использованы только в SELECT части запроса, либо в ORDER BY.
Для примера возьмем данные, которые мы использовали при разборе агрегирующих функций:</description></item><item><title>Проверка нескольких условий. AND, OR</title><link>http://orasql.ru/sql/basics/andor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/sql/basics/andor/</guid><description>При выборке данных мы можем указывать несколько условий одновременно. Для объединения условий можно использовать операторы and (логическое &amp;ldquo;И&amp;rdquo;) и or(логическое &amp;ldquo;ИЛИ&amp;rdquo;). Разберем каждый из них на примерах.
Пример №1: получим список блюд с рейтингом, меньшим чем 320, но со стоимостью большей, чем 2:
select * from dishes where rating &amp;lt; 320 and price &amp;gt; 2 Пример №2: получим список блюд, рейтинг которых варьируется от 280 до 320 включительно, и цена которых меньше 30:</description></item><item><title>Псевдостолбцы в Oracle</title><link>http://orasql.ru/sql/dbobjects/pseudocolumns/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/sql/dbobjects/pseudocolumns/</guid><description>К псевдостолбцам можно относиться как к обычным колонкам в таблице, за тем лишь исключением, что данные, которые они представляют, в таблице не хранятся.
Некоторые псевдостолбцы доступны только в определенном контексте, например, лишь при использовании рекурсивных запросов.
Мы рассмотрим не все псевдостолбцы, доступны в Oracle, а лишь самые основные и часто используемые. Полный их список и описание можно почитать в докумениации.
Мы будем использовать таблицу dishes, которая создается в части про операторы сравнения.</description></item><item><title>Схема БД. Её объекты</title><link>http://orasql.ru/plsql/basics/plsql_schema/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/plsql/basics/plsql_schema/</guid><description>Понятие схемы БД Схема - это совокупность всех объектов некоего пользователя, называемого владельцем схемы. Сюда входят таблицы, индексы, представления, триггеры, всё-всё-всё. То есть мы должны понимать, что когда мы говорим про функции или процедуры в PL/SQL, они находятся внутри схемы.
Мы не будем перечислять все возможные типы объектов, которые могут храниться в схеме, перечислим лишь несколько. Все нижеописанные объекты будут рассмотрены по отдельности далее в учебнике, здесь будет дана информация для первичного ознакомления с ними.</description></item><item><title>Distinct. Удаление дубликатов</title><link>http://orasql.ru/sql/standfunc/distinct/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/sql/standfunc/distinct/</guid><description>Оператор DISTINCT в SELECT запросах используется для удаления дублирующихся строк из выборки. В общем виде запрос выглядит следующим образом:
select distinct col_name1, col_name2, col_name3, ... from table_name Подготовка данных createtableemployees(idnumbernotnull,first_namevarchar2(50char)notnull,last_namevarchar2(100char),bddatenotnull,jobvarchar2(100));insertintoemployeesvalues(1,&amp;#39;Василий&amp;#39;,&amp;#39;Петров&amp;#39;,to_date(&amp;#39;07.10.1990&amp;#39;,&amp;#39;dd.mm.yyyy&amp;#39;),&amp;#39;Машинист&amp;#39;);insertintoemployeesvalues(2,&amp;#39;Александр&amp;#39;,&amp;#39;Сидоров&amp;#39;,to_date(&amp;#39;18.07.1980&amp;#39;,&amp;#39;dd.mm.yyyy&amp;#39;),&amp;#39;Бухгалтер&amp;#39;);insertintoemployeesvalues(3,&amp;#39;Евгения&amp;#39;,&amp;#39;Цветочкина&amp;#39;,to_date(&amp;#39;18.07.1978&amp;#39;,&amp;#39;dd.mm.yyyy&amp;#39;),&amp;#39;Бухгалтер&amp;#39;);insertintoemployeesvalues(4,&amp;#39;Владимир&amp;#39;,&amp;#39;Столяров&amp;#39;,to_date(&amp;#39;18.07.1977&amp;#39;,&amp;#39;dd.mm.yyyy&amp;#39;),&amp;#39;Слесарь&amp;#39;);insertintoemployeesvalues(5,&amp;#39;Владимир&amp;#39;,&amp;#39;Иванов&amp;#39;,to_date(&amp;#39;01.10.1987&amp;#39;,&amp;#39;dd.mm.yyyy&amp;#39;),&amp;#39;Сторож&amp;#39;);insertintoemployeesvalues(6,&amp;#39;Ирина&amp;#39;,&amp;#39;Васина&amp;#39;,to_date(&amp;#39;20.03.1962&amp;#39;,&amp;#39;dd.mm.yyyy&amp;#39;),&amp;#39;Специалист отдела кадров&amp;#39;);insertintoemployeesvalues(7,&amp;#39;Ирина&amp;#39;,&amp;#39;Иванова&amp;#39;,to_date(&amp;#39;31.12.1990&amp;#39;,&amp;#39;dd.mm.yyyy&amp;#39;),&amp;#39;Арт-директор&amp;#39;);insertintoemployeesvalues(8,&amp;#39;Евгения&amp;#39;,NULL,to_date(&amp;#39;18.07.1978&amp;#39;,&amp;#39;dd.mm.yyyy&amp;#39;),&amp;#39;Бухгалтер&amp;#39;);Итого, таблица employees выглядит следующим образом:
ID FIRST_NAME LAST_NAME BD JOB 1 Василий Петров 07-OCT-90 Машинист 2 Александр Сидоров 18-JUL-80 Бухгалтер 3 Евгения Цветочкина 18-JUL-78 Бухгалтер 4 Владимир Столяров 18-JUL-77 Слесарь 5 Владимир Иванов 01-OCT-87 Сторож 6 Ирина Васина 20-MAR-62 Специалист отдела кадров 7 Ирина Иванова 31-DEC-90 Арт-директор 8 Евгения - 18-JUL-78 Бухгалтер Удаление дупликатов из одной колонки Теперь получим список имён сотрудников:</description></item><item><title>Проверка значения на NULL</title><link>http://orasql.ru/sql/basics/isnull/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/sql/basics/isnull/</guid><description>Если обратить внимание на результаты запросов, выше, то можно заметить, что строка, содержащая NULL в колонке rating не была возвращена ни одним из них.
Как уже говорилось ранее, NULL - это отсутствие значения. Соответственно, он и не может быть больше, меньше, либо даже равняться какому-либо значению, даже себе.
Например, следующий запрос не вернет ни одной строки, хотя мы вроде как и указываем в запросе необходимый критерий - равенство NULL:
select d.</description></item><item><title>Функции в PL/SQL</title><link>http://orasql.ru/plsql/basics/plsql_functions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/plsql/basics/plsql_functions/</guid><description>Какую проблему помогают решить функции Общее описание функций уже было дано в предыдущей части, добавим лишь то, что функции - это один из способов сделать наш код более простым, понятным, компактным, а также избежать повторного написания однотипного кода.
Пример создания простой функции Предположим, что мы работаем над системой, в которой часто приходится считать размер скидок в зависимости от стоимости купленного товара. Размер скидки интересует нас с точностью до двух знаков после запятой.</description></item><item><title>IN, NOT IN</title><link>http://orasql.ru/sql/basics/innotin/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/sql/basics/innotin/</guid><description>Вхождение в набор данных. IN Условие IN позволяет ответить на следующий вопрос: &amp;ldquo;Входит ( IN ) ли значение в заданный набор данных?&amp;rdquo;.
Следующий пример вернет все блюда, рейтинг которых равен 320 либо 270:
select d.* from dishes d where d.rating IN (320, 270) Использовать можно любые типы, не только числа:
select d.* from dishes d where d.name IN ('Макароны с сыром', 'Овощной салат', 'Борщ') Следует помнить, что при сравнении строк учитывается регистр, т.</description></item><item><title>Процедуры в PL/SQL</title><link>http://orasql.ru/plsql/basics/plsql_procedures/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/plsql/basics/plsql_procedures/</guid><description>Пример создания простой процедуры create or replace procedure validate_age( page number ) is begin if page &amp;lt; 18 then dbms_output.put_line('Вам должно быть 18 или больше'); else dbms_output.put_line('Всё хорошо'); end if; end; Вызовем процедуру c несколькими параметрами:
begin validate_age(17); validate_age(40); end; / Вывод:
Вам должно быть 18 или больше Всё хорошо Как видно, особых отличий от создания функций нет. Основное отличие - процедуры не возвращают значений в таком виде, как это делают функции (через вызов return).</description></item><item><title>Взаимодействие PL/SQL и SQL. Переключение контекста</title><link>http://orasql.ru/plsql/basics/context/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/plsql/basics/context/</guid><description>Движки SQL и PL/SQL Когда Oracle получает команду выполнить какой-либо SQL запрос, он передаёт эту работу SQL движку. Следует взять за правило, что SQL движок является более быстрым, чем PL/SQL движок - все его функции встроены в ядро БД и написаны на языке C. Это основной язык для работы с данными в БД, он лучше оптимизирован. PL/SQL код, в свою очередь, выполняется PL/SQL движком. Он добавляет возможность процедурного программирования, но, в свою очередь, он медленнее, чем SQL, несмотря на то, что в Oracle постоянно работают над его улучшением.</description></item><item><title>Вхождение в диапазон. BETWEEN. NOT BETWEEN</title><link>http://orasql.ru/sql/basics/between/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/sql/basics/between/</guid><description>BETWEEN используется для того, чтобы проверить значение на вхождение в диапазон. Проверять вхождение в диапазон значений можно строки, числа и даты.
Пример №1: Получить список блюд, рейтинг которых колеблется от 270 до 320 включительно:
select d.* from dishes d where rating between 270 and 320 Следует помнить, что граничные значения диапазона всегда включаются при проверке, т.е. этот запрос идентичен следующему:
select d.* from dishes d where d.rating ≥ 270 and d.</description></item><item><title>Пакеты</title><link>http://orasql.ru/plsql/basics/packages/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/plsql/basics/packages/</guid><description>В данной части будут рассмотрены пакеты - основная сущность при разработке на PL/SQL. Пакеты используются для группировки функционала в именованные модули с возможностью разделения интерфейса и реализации. На самом деле, мы уже сталкивались с ними, когда рассматривали вывод на экран с использованием dbms_output.put_line. Dbms_output - это пакет, а put_line - процедура, объявленная в данном пакете.
Стуктура пакета Пакеты как правило состоят из спецификации и тела. Можно создать пакет без тела, только со спецификацией, такой вариант использования тоже будет рассмотрен.</description></item><item><title>Соединения таблиц</title><link>http://orasql.ru/sql/basics/joins/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/sql/basics/joins/</guid><description>Работать с одной таблицей в БД приходится редко. Как правило, данные распределены по нескольким таблицам, которые связаны между собой.
Подготовка данных Для демонстрации соединений понадобится несколько таблиц.
create table app_users( login varchar2(50 char) primary key, registration_date date default sysdate not null, email varchar2(200 char) not null ); comment on table app_users is 'Пользователи'; create table app_roles( role_id number(10) primary key, role_name varchar2(50) not null ); comment on table app_roles is 'Роли в системе'; create table user_roles( login varchar2(50 char) not null, role_id number(10) not null, constraint user_roles_login_fk foreign key(login) references app_users(login), constraint user_roles_role_id_fk foreign key(role_id) references app_roles(role_id) ); insert into app_users values('johndoe', sysdate, 'johndoe@johndoemail.</description></item><item><title>Древовидные структуры данных. Рекурсивные запросы</title><link>http://orasql.ru/sql/basics/recursive/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/sql/basics/recursive/</guid><description>Достаточно часто приходится иметь дело с древовидными структурами данных. Классическим примером является структура подразделений организации, где один отдел является частью другого, и при этом также состоит из нескольких подразделений. Также можно в виде дерева описать отношения между сотрудниками - кто кому приходится начальником; некий список документов, где один документ появляется на основании другого, а тот в свою очередь был создан на основании третьего, и т.п.
Реализация древовидных структур в РСУБД Для того, чтобы можно было листья дерева собрать воедино, нужно знать, как они соотносятся друг с другом.</description></item><item><title>Подзапросы в Oracle</title><link>http://orasql.ru/sql/basics/subqueries/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/sql/basics/subqueries/</guid><description>Подзапросы представляют собой обычные SQL-запросы, которые являются частью другого SQL-запроса.
Подзапросы - важная часть в изучении SQL. Некоторые данные просто не могут быть получены, если их не использовать. Далее будут рассмотрены примеры использования подзапросов в Oracle.
Подготовка тестовых данных create table books( book_id number primary key, book_name varchar2(200) not null, author varchar2(50 char) not null, release_year number not null ); create table book_orders( book_id number not null, quantity number(2) not null, order_date date not null ); comment on table books is 'Книги'; comment on table book_orders is 'Статистика продаж за день'; insert into books values(1, 'Властелин колец', 'Толкин', 1954); insert into books values(2, 'Гордость и предубеждение', 'Джейн Остин', 1813); insert into books values(3, 'Тёмные начала', 'Филип Пулман', 1995); insert into books values(4, 'Автостопом по галактике', 'Дуглас Адамс', 1979); insert into book_orders values(1, 1, to_date('31.</description></item><item><title>Exists. Наличие строк в подзапросе</title><link>http://orasql.ru/sql/basics/exists/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/sql/basics/exists/</guid><description>Оператор EXISTS имеет вид EXISTS(подзапрос), и возвращает истинное значение в том случае, если подзапрос в скобках возвращает хотя бы одну строку. Может использоваться с оператором NOT.
Примеры будем разбирать на данных из части про подзапросы.
Пример №1: Получить список книг, которые заказывались хотя бы раз.
Очевидно что ответом будут те книги, ссылки на которые есть в таблице book_orders. Нас устроит любая книга, которая имеет хотя бы один заказ, и поэтому задача легко решается с использованием EXISTS:</description></item><item><title>Subquery factoring. WITH</title><link>http://orasql.ru/sql/basics/with/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/sql/basics/with/</guid><description>Часть WITH SQL запроса используется для реализации так называемого Subquery factoring. Эта возможность позволяет задать подзапрос, который будет доступен в любом месте SQL запроса. Subquery factoring в некоторых случаях значительно упрощает чтение и написание запросов. Более того, велика вероятность того, что при использовании subquery factoring БД построит более оптимальный план выполнения запроса.
Используя Subquery factoring, вы говорите БД о том, что указанный подзапрос вероятно будет использоваться несколько раз в одном запросе, и БД сможет предпринять действия, чтобы более эффективно повторно использовать его.</description></item></channel></rss>