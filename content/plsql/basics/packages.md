---
Title: "Пакеты"
weight: 11
draft: true
toc: true
---

В данной части будут рассмотрены пакеты - основная сущность
в разработке на PL/SQL. Пакеты используются для группировки
функционала в именованные модули с возможностью разделения
интерфейса и реализации. На самом деле, мы уже сталкивались
с ними, когда рассматривали вывод на экран с использованием
`dbms_outpu.put_line`. `Dbms_output` - это пакет, а `put_line` - 
процедура, объявленная в данном пакете.

## Стуктура пакета

Пакеты как правило состоят из **спецификации** и **тела**.
Можно создать пакет без тела, только со спецификацией, такой
вариант использования тоже будет рассмотрен.

Спецификация пакета - это то, к чему можно обращаться при
работе с пакетом. В спецификации могут быть объявлены
типы, переменные, константы, сигнатуры процедур и функций.

Тело пакета содержит в себе код, необходимый для
реализации спецификации. Также он может содержать всё то же, что
спецификация - переменные, типы, константы и проч. Всё, что
содержится в теле, но не описано в спецификации, недоступно
для использования внешними модулями. Здесь можно провести аналогию
с публичными и приватными модификаторами доступа в ООП языках(
например, как `private` и `public` в Java).

![](/img/plsql/package_structure.png)

## Создание пакета

Общий синтаксис создания спецификации пакета выглядит
так:

```sql
create package pck_utils as
-- Specification code
end pck_utils;
```

Команда выше создаст пакет с названием `pck_utils`. Если
пакет с таким именем уже существует, будет выброшена ошибка,
и новый пакет не создастся. Чтобы заменить уже существующий
пакет, используется команда `create or replace`. На практике чаще
всего используют именно её:

```sql
create or replace package pck_utils as
-- Specification code
end pck_utils;
```

Тело пакета создаётся следующим образом:

```sql
create or replace package body pck_utils as
-- Specification code
end pck_utils;
```

Давайте создадим пакет и наполним его каким-нибудь функционалом:

```sql
create or replace package pck_date_utils as

-- Возвращает максимальную дату, 
-- используемую в системе
function maxdate return date;

-- Возвращает минимальную дату, 
-- используемую в системе
function mindate return date;

-- Добавляет указанное количество недель к
-- указанной дате. Для того, чтобы отнять
-- недели, нужно передать отрицательное число
function add_weeks(
    pdate date,
    pweeks number
) return date;

end pck_date_utils;
```

Это была спецификация пакета. Теперь создадим тело:

```sql
create or replace package body pck_date_utils as

function maxdate return date is
begin
    return to_date('4000.01.01', 'yyyy.mm.dd');
end;

function mindate return date is
begin
    return to_date('1800.01.01', 'yyyy.mm.dd');
end;

function add_weeks(
    pdate date,
    pweeks number
) return date
is
begin
    return pdate + (7 * pweeks);
end;

end pck_date_utils;
```

Теперь мы можем обращаться ко всему, что объявлено
в спецификации пакета в нашем коде. Обращение к содержимому
пакета осуществляется в виде `имя_пакета.объект`(под объектом
понимается всё, что объявлено в спецификации):

```sql
begin
    dbms_output.put_line(to_char(pck_date_utils.mindate, 'yyyy.mm.dd'));
    dbms_output.put_line(to_char(pck_date_utils.maxdate, 'yyyy.mm.dd'));
    dbms_output.put_line(to_char(pck_date_utils.add_weeks(sysdate, 3), 'yyyy.mm.dd'));
end;
```

Вывод:

```
1800.01.01
4000.01.01
2022.03.30
```

## Удаление пакета

Удаление производится командой `drop package`:

```sql
drop package pck_date_utils
```

## Пакеты без тела

Можно создать пакет, который не будет иметь тела.
Как правило, это пакеты, которые содержат публичные
константы, типы или переменные:

```sql
create package pck_user_gl as

-- Статусы пользователей
active constant number := 0;
deleted constant number := 1;
paused constant number := 2;

end pck_emp_gl;
```

В данном пакете содержатся константы для
описания статусов пользователей.
Теперь мы можем обращаться к статусам, объявленным в пакете:

```
begin
    dbms_output.put_line(pck_emp_gl.active);
    dbms_output.put_line(pck_emp_gl.paused);
    dbms_output.put_line(pck_emp_gl.deleted);
end;
```

Напомним, что констатны и переменные PL/SQL нельзя использовать в SQL запросах,
но они могут быть использованы в другом PL/SQL коде.

## Сессии

Каждая сессия в БД работает со своей копией пакета в памяти, что
означает, что состояние переменных пакета *локально для сессии,
использующей его*. Рассмотрим простой пример:

```sql
create or replace package pck_test as

current_number number := 10;

end pck_test;
```

Данный пакет содержит одну переменную `current_number`
со значением по-умолчанию, равным 10. Предположим, с пакетом будут
работать две сессии, А и Б:

Сессия А:

```sql
begin
    dbms_output.put_line(pck_test.current_number);
end;
```

Сессия Б:

```sql
begin
    dbms_output.put_line(pck_test.current_number);
end;
```

Результат будет одинаковым в двух сессиях:

```
10
```

Теперь изменим значение переменной в первой сессии:

```sql
-- Сессия А
begin
    pck_test.current_number := 20;
end;
```

После чего выведем содержимое переменной в двух сессиях:

```sql
-- Сессия А:
begin
    dbms_output.put_line(pck_test.current_number);
end;
```

```sql
-- Сессия Б:
begin
    dbms_output.put_line(pck_test.current_number);
end;
```

И получим следующий результат:

Сессия А:
```
20
```

Сессия Б:
```
10
```

Как видно, изменения переменной, произведённые в первой сессии,
не повлияли на значение той же переменной пакета во второй сессии.

## Порядок загрузки пакета в память

Помимо создания экземпляра пакета в памяти при первоначальном
обращении к нему, Oracle производит его инициализацию, состоящую
из следующих шагов:

- Присваивание первоначальных значений публичным константам
- Присваивание первоначальных значений публичным переменным
- Запуск блока инициализации

## Init

Блок инициализации находится в процедуре `init`. Это необязательная
часть пакета.

## Состояние пакета сбрасывается

- При перекомпиляции пакета
- Если хотя бы один из экземпляров пакетов был 

## SERIALLY_REUSABLE

todo: https://docs.oracle.com/cd/E11882_01/appdev.112/e25519/packages.htm#LNPLS99924
