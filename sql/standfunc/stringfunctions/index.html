<!doctype html><html><head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<link rel=stylesheet href=/css/superkube.min.css>
<link rel=stylesheet href=/css/main.css>
<script>var clicky_site_ids=clicky_site_ids||[];clicky_site_ids.push(101305633)</script>
<script async src=//static.getclicky.com/js></script>
<title>Учебник Oracle SQL, PL/SQL | Функции для работы со строками</title>
</head>
<body><div class="navbar bg-dark mb-10">
<div class="navbar-container container edges centered">
<div class=navbar-brand>
<a href=/ class=brand>
Orasql.ru
</a>
</div>
<div class="navbar-nav ml-6">
<nav class="nav nav-light nav-semibold">
<ul class=nav-list>
<li class=nav-item><a href=/book/ class=nav-link>Книга</a></li>
</ul>
</nav>
<nav class="nav nav-light nav-semibold">
<ul class=nav-list>
<li class=nav-item><a href=https://github.com/cyevgeniy/orasqlru class=nav-link>Github</a></li>
</ul>
</nav>
</div>
</div>
</div>
<div id=container class="container-medium edges centered">
<div class="doc-head mb-4 container-10">
<h5 class="heading-micro heading-muted">Стандарные функции</h5>
<h1 class="heading-huge heading-heavy">Функции для работы со строками</h1>
</div>
<div class="doc-toc mt-6 mb-6">
<nav class="menu menu-underline menu-medium menu-numbered">
<ul class=menu-list>
<li class=menu-item>
<a href=#upper-lower class=menu-link>UPPER, LOWER</a>
</li><li class=menu-item>
<a href=#%d0%ba%d0%be%d0%bd%d0%ba%d0%b0%d1%82%d0%b5%d0%bd%d0%b0%d1%86%d0%b8%d1%8f-%d1%81%d1%82%d1%80%d0%be%d0%ba class=menu-link>Конкатенация строк</a>
</li><li class=menu-item>
<a href=#%d0%bf%d0%be%d0%b8%d1%81%d0%ba-%d0%bf%d0%be%d0%b4%d1%81%d1%82%d1%80%d0%be%d0%ba%d0%b8 class=menu-link>Поиск подстроки</a>
</li><li class=menu-item>
<a href=#%d0%bf%d0%be%d0%b4%d0%be%d0%b1%d0%b8%d0%b5-%d1%81%d1%82%d1%80%d0%be%d0%ba-like class=menu-link>Подобие строк. Like</a>
</li><li class=menu-item>
<a href=#%d0%bf%d1%80%d0%b8%d0%b2%d0%b5%d0%b4%d0%b5%d0%bd%d0%b8%d0%b5-%d0%ba-%d0%b2%d0%b5%d1%80%d1%85%d0%bd%d0%b5%d0%bc%d1%83-%d1%80%d0%b5%d0%b3%d0%b8%d1%81%d1%82%d1%80%d1%83-initcap class=menu-link>Приведение к верхнему регистру. INITCAP</a>
</li><li class=menu-item>
<a href=#%d0%b7%d0%b0%d0%bc%d0%b5%d0%bd%d0%b0-%d0%bf%d0%be%d0%b4%d1%81%d1%82%d1%80%d0%be%d0%ba%d0%b8-replace class=menu-link>Замена подстроки. REPLACE</a>
</li><li class=menu-item>
<a href=#%d1%83%d0%b4%d0%b0%d0%bb%d0%b5%d0%bd%d0%b8%d0%b5-%d0%bf%d1%80%d0%be%d0%b1%d0%b5%d0%bb%d0%be%d0%b2-trim class=menu-link>Удаление пробелов. TRIM</a>
</li><li class=menu-item>
<a href=#lpad-rpad class=menu-link>LPAD, RPAD</a>
</li></ul></nav>
</div>
<p>Создадим тестовую таблицу.</p>
<pre><code>create table articles(
    title varchar2(50) not null,
    author varchar2(50) not null,
    msg varchar2(300) not null,
    publish_date date not null
);

comment on table articles is 'Твиты';
comment on column articles.title is 'Заголовок';
comment on column articles.author is 'Автор';
comment on column articles.msg is 'Сообщение';

insert into articles values ('Новый фотоаппарат!', 'johndoe',
    'Сегодня купил себе новый фотоаппарат. Надеюсь, у меня будут получаться отличные фотографии!', sysdate);
insert into articles values ('Насобирал денег', 'johndoe',
    'Целый год я шел к этой цели, и вот наконец-то у меня все получилось, и заветная сумма собрана!', sysdate - 1);
insert into articles values ('Задался целью', 'johndoe',
    'Итак, я задался целью купить себе фотоаппарат. Для начала нужно насобирать денег на него.', sysdate - 2);
insert into articles values ('Сходил в ресторан!', 'user003',
    'Пришел из ресторана. Еда была просто восхитительна!', sysdate - 3);
insert into articles values ('Съездили в отпуск!', 'artem69',
    'Наконец-то выбрались с женой и детьми в отпуск, было замечательно!', sysdate - 4);
</code></pre>
<p>Таблица <code>articles</code> представляет собой место хранения сообщений
пользователей, что-то вроде twitter.</p>
<h2 id=upper-lower>UPPER, LOWER</h2>
<p>Данные функции уже описывались раньше.</p>
<ul>
<li><code>UPPER</code>: приводит строку к верхнему регистру</li>
<li><code>LOWER</code>: приводит строку к нижнему регистру</li>
</ul>
<p>Рекомендуется использовать одну из этих функций, если нужно сравнить две
строки между собой без учета регистра символов.</p>
<h2 id=конкатенация-строк>Конкатенация строк</h2>
<p>Конкатенация - это &ldquo;склейка&rdquo; строк. Т.е., если у нас есть 2 строки -
&ldquo;Новый&rdquo;, &ldquo;фотоаппарат&rdquo;, то результатом конкатенации будет строка &ldquo;Новый
фотоаппарат&rdquo;.</p>
<p>Для склейки строк в Oracle используется оператор <code>||</code>.</p>
<pre><code>select 'Автор:' || art.author frmt_author,
       'Заголовок:&quot;' || art.title  || '&quot;' frmt_title
from articles art
</code></pre>
<p><img src=/img/4_strings/str_concat.png alt></p>
<h2 id=поиск-подстроки>Поиск подстроки</h2>
<p>Для того, чтобы найти вхождение одной строки в другую, используется
функция <code>INSTR</code>. Она возвращает позицию вхождения одной строки в другую.
Если вхождения не обнаружено, то в качестве результата будет возвращён
0.</p>
<p>Следующий запрос возвращает позицию, начиная с которой в заголовках
записей пользователей встречается символ восклицательного знака:</p>
<pre><code>select a.title,
       instr(a.title, '!') pos
from articles a
</code></pre>
<p><img src=/img/4_strings/instr_!.png alt></p>
<p>Как видно, для тех заголовков, которые не содержат восклицательный знак,
функция <code>INSTR</code> вернула 0.</p>
<p>В функции <code>INSTR</code> можно задавать позицию, начиная с которой следует
производить поиск вхождения:</p>
<pre><code>select a.title,
       instr(a.title, 'о', 3) pos
from articles a
</code></pre>
<p><img src=/img/4_strings/instr_o.png alt></p>
<p>Данный запрос вернет позицию буквы о в заголовках записей, но поиск
будет производить лишь начиная с 3-го символа заголовка.</p>
<p>Так, в строке &ldquo;Новый фотоаппарат&rdquo; мы получили результат 8, хотя буква о
есть и раньше - на второй позиции.</p>
<p>В качестве стартовой позиции поиска можно указывать отрицательное число.
В этом случае функция отсчитает от конца строки указанное количество
символов и будет производить поиск начиная от этой позиции и заканчивая
началом строки:</p>
<pre><code>select a.title,
       instr(a.title, 'а', -4) pos
from articles a
</code></pre>
<p><img src=/img/4_strings/instr_4a.png alt></p>
<p>Также можно указать, какое по счету совпадение нужно искать(4-ый
параметр в функции <code>INSTR</code>):</p>
<pre><code>select a.title,
       instr(a.title, 'о', 1, 2) pos
from articles a
</code></pre>
<p><img src=/img/4_strings/instr_o1_2.png alt></p>
<h2 id=подобие-строк-like>Подобие строк. Like</h2>
<p>Для рассмотрения этой темы будем использовать данные из части про
<a href=/sql/basics/orderby/ title=сортировка>сортировку</a>.</p>
<p>Предположим, нам понадобилось посмотреть, какие чаи есть у нас в меню. В
данном примере единственный способ, которым мы можем определить, что
блюдо является чаем - это проверить, содержится ли слово чай в
наименовании.</p>
<p>Но оператор сравнения здесь не подойдет, так как он вернет лишь те
строки, которые будут полностью совпадать со строкой Чай.</p>
<p>Перед рассмотрением примера добавим в таблицу меню немного чайных блюд:</p>
<pre><code>insert into dishes(name, price, rating) values ('Зеленый чай', 1, 100);
insert into dishes(name, price, rating) values ('Чай%', 2, 100);
insert into dishes(name, price, rating) values ('Чай+', 1, 200);
insert into dishes(name, price, rating) values ('Чай!', 1, 666);
</code></pre>
<p>Гениальные маркетологи решили, что будут добавлять по одному символу в
конце слова чай для обозначения его крепости - &ldquo;чай%&rdquo; - совсем
слабенький, &ldquo;чай+&rdquo; взбодрит с утра, а с &ldquo;чаем!&rdquo; можно забыть про сон на
ближайшие сутки. Не будем задумываться, почему именно так, а просто
примем это как есть.</p>
<p>Итак, первый пример использования <code>LIKE</code>:</p>
<pre><code>select d.*
from dishes d
where d.name like 'Чай%'
</code></pre>
<p><img src=/img/3_select/like_tea_percent.png alt></p>
<p>Как видно, были получены все блюда, наименования которых начиналось с
последовательности символов, составляющей слово Чай. Символ &ldquo;%&rdquo; в
условии <code>LIKE</code> соответствует любой последовательности символов. Т.е.
предыдущий запрос можно было читать так: &ldquo;Получить все блюда, первые
символы наименований которых составляют слово Чай, а после этих символов
следует последовательность из любых символов в любом количестве, мне не
важно&rdquo;. Кстати, в результат не попал зеленый чай - первые 3 символа
наименования у него равны &ldquo;Зел&rdquo;, но никак не &ldquo;Чай&rdquo;.</p>
<p>Если не указывать символ &ldquo;%&rdquo;, то запрос не вернет никаких данных:</p>
<pre><code>select d.*
from dishes d
where d.name like 'Чай'
</code></pre>
<p><img src=/img/3_select/no_data_found.png alt></p>
<p>При задании шаблонов в LIKE можно использовать следующие символы
соответствия:</p>
<ul>
<li>&ldquo;%"(знак процента). Ему соответствует 0 или больше символов в
значении.</li>
<li>&ldquo;_"(нижнее подчеркивание). Ему соответствует ровно один символ в
значении.</li>
</ul>
<p>Получим все чаи, названия которых придумали маркетологи(а это любой 1
символ после слова &ldquo;чай&rdquo;):</p>
<pre><code>select d.*
from dishes d
where d.name like ('Чай_')
</code></pre>
<p><img src=/img/3_select/like_tea_.png alt></p>
<p>Также, как и при обычном сравнении, учитывается регистр строк. Следующий
запрос не вернет никаких данных, т.к. нет блюд, начинающихся со строки
&ldquo;чай&rdquo;, есть только блюда, начинающиеся на &ldquo;Чай&rdquo;(первая буква заглавная):</p>
<pre><code>select d.*
from dishes d
where d.name like ('чай%')
</code></pre>
<p><img src=/img/3_select/no_data_found.png alt></p>
<p>Получим только зеленый чай:</p>
<pre><code>select d.*
from dishes d
where d.name like ('%чай')
</code></pre>
<p><img src=/img/3_select/like_percent_tea.png alt></p>
<p>Здесь символ процента был перемещен перед словом &ldquo;чай&rdquo;, что означает:
&ldquo;Любая последовательность символов(или их отсутствие), заканчивающаяся
словом чай&rdquo;.</p>
<p>А для того, чтобы получить список всех блюд, в наименовании которых
содержится слово &ldquo;чай&rdquo;, можно написать следующий запрос:</p>
<pre><code>select d.*
from dishes d
where upper(d.name) like upper('%чай%')
</code></pre>
<p><img src=/img/3_select/like_percent_tea_percent.png alt></p>
<h3 id=выражение-escape-в-like>Выражение ESCAPE в LIKE</h3>
<p>Перед рассмотрением выражения опять добавим немного данных в таблицу
<code>dishes</code>:</p>
<pre><code>insert into dishes values ('Кофе(0.4% кофеина)', 30, 20);
insert into dishes values ('Кофе(0.3% кофеина)', 30, 20);
insert into dishes values ('Кофе(0.1% кофеина)', 30, 20);
insert into dishes values ('Кофе(без кофеина)', 30, 20);
</code></pre>
<p>Перед нами стоит задача: получить список кофейных блюд, содержащих
кофеин.</p>
<p>Можно выделить некоторый список признаков, по которым мы сможем
определить, что кофе с кофеином:</p>
<ul>
<li>Наименование начинается со слова &ldquo;Кофе&rdquo;</li>
<li>Если кофе с кофеином, то в скобках указывается его процентное
содержание в виде &ldquo;n% кофеина&rdquo;, где n - некоторое число.</li>
</ul>
<p>На основании этих заключений можно написать следующий запрос:</p>
<pre><code>select d.*
from dishes d
where d.name like ('Кофе%кофеина')
</code></pre>
<p><img src=/img/3_select/no_data_found.png alt></p>
<p>В чем проблема, должно быть понятно - в том, что символ &ldquo;%&rdquo; в условии
<code>LIKE</code> обозначает совпадение с 0 или больше любых символов.</p>
<p>Для того, чтобы учитывать непосредственно символ &ldquo;%&rdquo; в строке, условие
<code>LIKE</code> немного видоизменяется:</p>
<pre><code>select d.*
from dishes d
where d.name like ('Кофе%\% кофеина%') escape '\'
</code></pre>
<p><img src=/img/3_select/cofee_with_cofein.png alt></p>
<p>Здесь после ключевого слова escape мы указываем символ, который будет
экранирующим, т.е. если перед символами<code>%</code> будет стоять символ <code>\</code>, то
он будет рассматриваться как совпадение с одним символом <code>%</code>, а не как
совпадение 0 и больше любых символов.</p>
<h2 id=приведение-к-верхнему-регистру-initcap>Приведение к верхнему регистру. INITCAP</h2>
<p>Функция <code>INITCAP</code> делает первую букву каждого слова заглавной, оставляя
остальную часть слова в нижнем регистре.</p>
<pre><code>select initcap(art.author)
from articles art
</code></pre>
<p><img src=/img/4_strings/author_initcap.png alt></p>
<pre><code>select initcap(art.msg) msg_initcap
from articles art
</code></pre>
<p><img src=/img/4_strings/msg_initcap.png alt></p>
<p>Если строка состоит из нескольких слов, то в каждом из этих слов первая
буква будет заглавной, а остальные - прописными.</p>
<h2 id=замена-подстроки-replace>Замена подстроки. REPLACE</h2>
<p>Для замены подстроки в строке используется функция <code>REPLACE</code>. Данная
функция принимает 3 параметра, из них последний - не обязательный:</p>
<pre><code>replace(исходная_строка, что_меняем, на_что_меняем)
</code></pre>
<p>В случае, если не указать, на какую строку производить замену, то
совпадения будут просто уделены из исходной строки.</p>
<p>Например, получим все &ldquo;твиты&rdquo; пользователя johndoe, но в заголовке поста
заменим слово &ldquo;фотоаппарат&rdquo; заменим на слово &ldquo;мыльница&rdquo;:</p>
<pre><code>select replace(a.title, 'фотоаппарат', 'мыльница') new_title,
       a.msg
from articles a
where a.author = 'johndoe'
</code></pre>
<p><img src=/img/4_strings/replace_photo.png alt></p>
<h2 id=удаление-пробелов-trim>Удаление пробелов. TRIM</h2>
<p>Есть 3 основных функции для удаления &ldquo;лишних&rdquo; пробелов из строки:</p>
<ul>
<li><code>trim</code> - удалить пробелы вначале и в конце строки</li>
<li><code>ltrim</code> - удалить пробелы вначале строки (слева)</li>
<li><code>rtrim</code> - удалить пробелы в конце строки (справа)</li>
</ul>
<pre><code>select trim('    John Doe      ') from dual;
select rtrim('    John Doe     ') from dual;
select ltrim('    John Doe    ') from dual;
-- То же самое, что и trim
select ltrim(rtrim('     John Doe    ')) from dual;
</code></pre>
<h2 id=lpad-rpad>LPAD, RPAD</h2>
<p>Эти функции используются, чтобы дополнить строку какими-либо символами
до определенной длины.</p>
<p><code>LPAD</code> (left padding) используется для дополнения строки символами
слева, а <code>RPAD</code> (right padding) - для дополнения справа.</p>
<pre><code>select lpad('1', 5, '0') n1,
       lpad('10', 5, '0') n2,
       lpad('some_str', 10) n2_1,
       rpad('38', 5, '0') n3,
       rpad('3', 5, '0') n4
from dual
</code></pre>
<p><img src=/img/4_strings/lpad_rpad.png alt></p>
<p>Первый параметр в этой функции - строка, которую нужно дополнить, второй</p>
<ul>
<li>длина строки, которую мы хотим получить, а третий - символы, которыми
будем дополнять строку. Третий параметр не обязателен, и если его не
указывать, то строка будет дополняться пробелами, как в колонке <code>n2_1</code>.</li>
</ul>
<nav class="pagination mb-3">
<ul class=pagination-list>
<li class="pagination-item ml-auto">
<a href=http://orasql.ru/sql/standfunc/nullfunctions/ class="pagination-link pagination-next"> Функции для работы с NULL > </a>
</li>
</ul>
</nav>
</div>
<footer class="footer b-dark-low b-top">
<div class="footer-container container centered edges">
<div class="footer-body mt-10">
<nav class="nav nav-muted nav-menu-sm"><ul class=nav-list>
<li class=nav-item><a href=/ class=nav-link>Orasql.ru</a></li>
<li class=nav-item><a href=/ class=nav-link>Учебник</a></li>
<li class=nav-item><p class="text-medium text-moderated">Email: orasqlru@gmail.com</p></li>
</ul>
</nav>
</div>
<div class="footer-copy mt-6 pt-6 b-dark-7 b-top">
<p class="text-medium text-moderated">© Orasql.ru <br> 2019-2021</p>
</div>
</div>
</footer>
</body>
</html>