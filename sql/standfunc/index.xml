<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Стандарные функции on Учебник Oracle SQL, PL/SQL</title><link>http://orasql.ru/sql/standfunc/</link><description>Recent content in Стандарные функции on Учебник Oracle SQL, PL/SQL</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="http://orasql.ru/sql/standfunc/index.xml" rel="self" type="application/rss+xml"/><item><title>Функции для работы со строками</title><link>http://orasql.ru/sql/standfunc/stringfunctions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/sql/standfunc/stringfunctions/</guid><description>Создадим тестовую таблицу.
create table articles( title varchar2(50) not null, author varchar2(50) not null, msg varchar2(300) not null, publish_date date not null ); comment on table articles is 'Твиты'; comment on column articles.title is 'Заголовок'; comment on column articles.author is 'Автор'; comment on column articles.msg is 'Сообщение'; insert into articles values ('Новый фотоаппарат!', 'johndoe', 'Сегодня купил себе новый фотоаппарат. Надеюсь, у меня будут получаться отличные фотографии!', sysdate); insert into articles values ('Насобирал денег', 'johndoe', 'Целый год я шел к этой цели, и вот наконец-то у меня все получилось, и заветная сумма собрана!</description></item><item><title>Функции для работы с NULL</title><link>http://orasql.ru/sql/standfunc/nullfunctions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/sql/standfunc/nullfunctions/</guid><description>Так как NULL - особое значение, то он удостоился отдельных функций в Oracle, которые умеют работать с ним &amp;ldquo;из коробки&amp;rdquo;.
Подготовка тестовых данных Работать будем со следующей таблицей:
create table profiles( login varchar2(30) primary key, last_updated date, status varchar2(50) ); comment on table profiles is 'Профили форума'; comment on column profiles.last_updated is 'Дата последнего обновления'; comment on column profiles.status is 'Статус'; insert into profiles(login, last_updated, status) values ('johndoe', to_date('01.01.2009 23:40', 'dd.</description></item><item><title>Условные функции</title><link>http://orasql.ru/sql/standfunc/conditional/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/sql/standfunc/conditional/</guid><description>Условные функции - это такие функции, которые могут возвращать разные результаты в зависимости от выполнения тех или иных условий.
В качестве тестовых данным будем использовать таблицу из части про функции для работы с NULL.
DECODE Функция DECODE в общем случае имеет следующий вид:
DECODE(что сравниваем, значение1, результат1, значение2, результат2, значение3, результат3, .... значениеN, результатN, значение по-умолчанию) Первым DECODE принимает параметр, значение которого будет сравниваться по очереди со списком значений, и в случае, когда он совпадет с одним из перечисленных, будет возвращен соответствующий результат.</description></item><item><title>Битовые операции</title><link>http://orasql.ru/sql/standfunc/bit/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/sql/standfunc/bit/</guid><description>Битовые операции при работе с БД применяются редко. Тем не менее, работа с отдельными битами поддерживается в БД Oracle, и в некоторых случаях может быть использована в весьма элегантном виде.
Тестовые данные create table docs( id number not null primary key, doc_num varchar2(100 char) not null, bit_access number default 0 not null ); comment on table docs is 'Документы'; comment on column docs.bit_access is 'Уровни доступа(1 бит - чтение, 2 - редактирование, 3 - удаление)'; insert into docs values(1, '1-1', 0); insert into docs values(2, '2-1', 1); insert into docs values(3, '2-2', 4); insert into docs values(4, '3-1', 3); insert into docs values(5, '4-1', 7); Колонка bit_access хранит в себе число, каждый бит которого отвечает за наличие(1) или отсутствие(0) доступа на произведение операций с данной строкой таблицы(документом).</description></item><item><title>Агрегирующие функции</title><link>http://orasql.ru/sql/standfunc/aggregation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/sql/standfunc/aggregation/</guid><description>Агрегирующие функции - это такие функции, которые выполняются не для каждой строки отдельно, а для определенных групп данных.
Подготовка данных create table employees( id number not null, first_name varchar2(50 char) not null, last_name varchar2(100 char), bd date not null, job varchar2(100) ); insert into employees values(1, 'Василий', 'Петров', to_date('07.10.1990', 'dd.mm.yyyy'), 'Машинист'); insert into employees values(2, 'Александр', 'Сидоров', to_date('18.07.1980', 'dd.mm.yyyy'), 'Бухгалтер'); insert into employees values(3, 'Евгения', 'Цветочкина', to_date('18.07.1978', 'dd.mm.yyyy'), 'Бухгалтер'); insert into employees values(4, 'Владимир', 'Столяров', to_date('18.</description></item><item><title>Работа с датами в Oracle</title><link>http://orasql.ru/sql/standfunc/datefunctions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/sql/standfunc/datefunctions/</guid><description>В БД Oracle для работы с датами предназначены 2 типа - DATE и TIMESTAMP.
Отдельно можно упомянуть INTERVAL - интервальный тип, который хранит диапазон между двумя датами.
Тип DATE Тип DATE используется чаще всего, когда необходимо работать с датами в БД Oracle. Он позволяет хранить даты с точностью до секунд.
Некоторые БД, например MySQL, также имеют тип DATE, но там может храниться дата лишь с точностью до дня.
Приведение строки к дате Одна из часто встречающихся ситуаций - необходимость представить строку в виде типа данных DATE.</description></item><item><title>Аналитические функции</title><link>http://orasql.ru/sql/standfunc/analytics/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/sql/standfunc/analytics/</guid><description>Аналитические функции - очень мощный инструмент в SQL. Со слов Тома Кайта, можно написать отдельную книгу по аналитическим функциям, настолько они полезны.
Аналитические функции - это те же агрегирующие функции, но их главная особенность в том, что они работают без необходимости группировки строк.
Аналитические функции выполняются последними в запросе, поэтому они могут быть использованы только в SELECT части запроса, либо в ORDER BY.
Для примера возьмем данные, которые мы использовали при разборе агрегирующих функций:</description></item><item><title>Distinct. Удаление дубликатов</title><link>http://orasql.ru/sql/standfunc/distinct/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/sql/standfunc/distinct/</guid><description>Оператор DISTINCT в SELECT запросах используется для удаления дублирующихся строк из выборки. В общем виде запрос выглядит следующим образом:
select distinct col_name1, col_name2, col_name3, ... from table_name Подготовка данных createtableemployees(idnumbernotnull,first_namevarchar2(50char)notnull,last_namevarchar2(100char),bddatenotnull,jobvarchar2(100));insertintoemployeesvalues(1,&amp;#39;Василий&amp;#39;,&amp;#39;Петров&amp;#39;,to_date(&amp;#39;07.10.1990&amp;#39;,&amp;#39;dd.mm.yyyy&amp;#39;),&amp;#39;Машинист&amp;#39;);insertintoemployeesvalues(2,&amp;#39;Александр&amp;#39;,&amp;#39;Сидоров&amp;#39;,to_date(&amp;#39;18.07.1980&amp;#39;,&amp;#39;dd.mm.yyyy&amp;#39;),&amp;#39;Бухгалтер&amp;#39;);insertintoemployeesvalues(3,&amp;#39;Евгения&amp;#39;,&amp;#39;Цветочкина&amp;#39;,to_date(&amp;#39;18.07.1978&amp;#39;,&amp;#39;dd.mm.yyyy&amp;#39;),&amp;#39;Бухгалтер&amp;#39;);insertintoemployeesvalues(4,&amp;#39;Владимир&amp;#39;,&amp;#39;Столяров&amp;#39;,to_date(&amp;#39;18.07.1977&amp;#39;,&amp;#39;dd.mm.yyyy&amp;#39;),&amp;#39;Слесарь&amp;#39;);insertintoemployeesvalues(5,&amp;#39;Владимир&amp;#39;,&amp;#39;Иванов&amp;#39;,to_date(&amp;#39;01.10.1987&amp;#39;,&amp;#39;dd.mm.yyyy&amp;#39;),&amp;#39;Сторож&amp;#39;);insertintoemployeesvalues(6,&amp;#39;Ирина&amp;#39;,&amp;#39;Васина&amp;#39;,to_date(&amp;#39;20.03.1962&amp;#39;,&amp;#39;dd.mm.yyyy&amp;#39;),&amp;#39;Специалист отдела кадров&amp;#39;);insertintoemployeesvalues(7,&amp;#39;Ирина&amp;#39;,&amp;#39;Иванова&amp;#39;,to_date(&amp;#39;31.12.1990&amp;#39;,&amp;#39;dd.mm.yyyy&amp;#39;),&amp;#39;Арт-директор&amp;#39;);insertintoemployeesvalues(8,&amp;#39;Евгения&amp;#39;,NULL,to_date(&amp;#39;18.07.1978&amp;#39;,&amp;#39;dd.mm.yyyy&amp;#39;),&amp;#39;Бухгалтер&amp;#39;);Итого, таблица employees выглядит следующим образом:
ID FIRST_NAME LAST_NAME BD JOB 1 Василий Петров 07-OCT-90 Машинист 2 Александр Сидоров 18-JUL-80 Бухгалтер 3 Евгения Цветочкина 18-JUL-78 Бухгалтер 4 Владимир Столяров 18-JUL-77 Слесарь 5 Владимир Иванов 01-OCT-87 Сторож 6 Ирина Васина 20-MAR-62 Специалист отдела кадров 7 Ирина Иванова 31-DEC-90 Арт-директор 8 Евгения - 18-JUL-78 Бухгалтер Удаление дупликатов из одной колонки Теперь получим список имён сотрудников:</description></item></channel></rss>