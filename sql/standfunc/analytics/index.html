<!doctype html><html><head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<link rel=stylesheet href=/css/superkube.min.css>
<link rel=stylesheet href=/css/main.css>
<title>Учебник Oracle SQL, PL/SQL | Аналитические функции</title>
</head>
<body><div class="navbar bg-dark mb-10">
<div class="navbar-container container edges centered">
<div class=navbar-brand>
<a href=/ class=brand>
Orasql.ru
</a>
</div>
<div class="navbar-nav ml-6">
<nav class="nav nav-light nav-semibold">
<ul class=nav-list>
<li class=nav-item><a href=/book/ class=nav-link>Книга</a></li>
</ul>
</nav>
<nav class="nav nav-light nav-semibold">
<ul class=nav-list>
<li class=nav-item><a href=https://github.com/cyevgeniy/orasqlru class=nav-link>Github</a></li>
</ul>
</nav>
</div>
</div>
</div>
<div id=container class="container-medium edges centered">
<div class="doc-head mb-4 container-10">
<h5 class="heading-micro heading-muted">Стандарные функции</h5>
<h1 class="heading-huge heading-heavy">Аналитические функции</h1>
</div>
<div class="doc-toc mt-6 mb-6">
<nav class="menu menu-underline menu-medium menu-numbered">
<ul class=menu-list>
<li class=menu-item>
<a href=#%d0%ba%d0%be%d0%b3%d0%b4%d0%b0-%d0%b0%d0%b3%d1%80%d0%b5%d0%b3%d0%b8%d1%80%d1%83%d1%8e%d1%89%d0%b0%d1%8f-%d1%84%d1%83%d0%bd%d0%ba%d1%86%d0%b8%d1%8f-%d1%81%d1%82%d0%b0%d0%bd%d0%be%d0%b2%d0%b8%d1%82%d1%81%d1%8f-%d0%b0%d0%bd%d0%b0%d0%bb%d0%b8%d1%82%d0%b8%d1%87%d0%b5%d1%81%d0%ba%d0%be%d0%b9 class=menu-link>Когда агрегирующая функция становится аналитической</a>
</li><li class=menu-item>
<a href=#%d0%bf%d0%be%d0%b4%d1%81%d1%87%d0%b5%d1%82-%d1%80%d0%b5%d0%b7%d1%83%d0%bb%d1%8c%d1%82%d0%b0%d1%82%d0%be%d0%b2-%d0%bf%d0%be-%d0%b3%d1%80%d1%83%d0%bf%d0%bf%d0%b0%d0%bc-partition-by class=menu-link>Подсчет результатов по группам. Partition by</a>
</li><li class=menu-item>
<a href=#%d0%bf%d0%be%d1%80%d1%8f%d0%b4%d0%be%d0%ba-%d0%b2%d1%8b%d1%87%d0%b8%d1%81%d0%bb%d0%b5%d0%bd%d0%b8%d1%8f-order-by class=menu-link>Порядок вычисления. Order by</a>
</li><li class=menu-item>
<a href=#%d0%b4%d0%b8%d0%b0%d0%bf%d0%b0%d0%b7%d0%be%d0%bd-%d1%80%d0%b0%d0%b1%d0%be%d1%82%d1%8b-%d0%b0%d0%bd%d0%b0%d0%bb%d0%b8%d1%82%d0%b8%d1%87%d0%b5%d1%81%d0%ba%d0%b8%d1%85-%d1%84%d1%83%d0%bd%d0%ba%d1%86%d0%b8%d0%b9 class=menu-link>Диапазон работы аналитических функций</a>
</li><li class=menu-item>
<a href=#%d1%81%d1%82%d1%80%d0%be%d0%ba%d0%b8-%d0%b8-%d0%b7%d0%bd%d0%b0%d1%87%d0%b5%d0%bd%d0%b8%d1%8f class=menu-link>Строки и значения</a>
</li><li class=menu-item>
<a href=#%d1%81%d0%bc%d0%b5%d1%89%d0%b5%d0%bd%d0%b8%d1%8f-%d0%bf%d1%80%d0%b8-%d0%be%d0%bf%d1%80%d0%b5%d0%b4%d0%b5%d0%bb%d0%b5%d0%bd%d0%b8%d0%b8-%d0%be%d0%ba%d0%bd%d0%b0 class=menu-link>Смещения при определении окна</a>
</li><li class=menu-item>
<a href=#%d0%be%d0%b3%d1%80%d0%b0%d0%bd%d0%b8%d1%87%d0%b5%d0%bd%d0%b8%d1%8f-%d0%bd%d0%b0-order-by class=menu-link>Ограничения на ORDER BY</a>
</li></ul></nav>
</div>
<p>Аналитические функции - очень мощный инструмент в SQL. Со слов Тома
Кайта, можно написать отдельную книгу по аналитическим функциям,
настолько они полезны.</p>
<p>Аналитические функции - это те же агрегирующие функции, но их главная
особенность в том, что они работают без необходимости группировки строк.</p>
<p>Аналитические функции выполняются последними в запросе, поэтому они
могут быть использованы только в <code>SELECT</code> части запроса, либо в
<code>ORDER BY</code>.</p>
<p>Для примера возьмем данные, которые мы использовали при разборе
агрегирующих функций:</p>
<pre><code>alter table employees
add (exp number);

merge into employees emp
using (select level lvl, rownum * 10 exp
       from dual
       connect by level &lt;= 4) val
on (emp.id = val.lvl)
when matched then
    update
    set emp.exp = val.exp;
</code></pre>
<p>Посмотрим, какие данные теперь хранятся в таблице:</p>
<pre><code>select *
from employees
</code></pre>
<p><img src=/img/16_analytic/all_employees.png alt></p>
<p>Теперь напишем запрос, который бы возвращал максимальный стаж среди всех
сотрудников отдельной колонкой. Для этого можно использовать подзапрос:</p>
<pre><code>select id,
       first_name,
       last_name,
       (select max(exp) from employees) max_exp
from employees
</code></pre>
<p><img src=/img/16_analytic/subq_max_exp.png alt></p>
<p>Усложним задачу: напишем запрос, который будет возвращать отдельной
колонкой максимальный стаж на должности каждого сотрудника. Для этого
также можно использовать подзапрос, только уже коррелированный:</p>
<pre><code>select emp.first_name,
       emp.last_name,
       emp.job,
       (select max(exp) from employees where job = emp.job) max_exp
from employees emp
</code></pre>
<p><img src=/img/16_analytic/subq_max_job.png alt></p>
<p>Теперь решим эти же задачи при помощи аналитический функций:</p>
<pre><code>select emp.first_name,
       emp.last_name,
       emp.job,
       max(exp) over () max_exp
from employees emp

select emp.first_name,
       emp.last_name,
       emp.job,
       max(exp) over (partition by job) max_exp
from employees emp
</code></pre>
<p>Аналитические функции позволяют использовать агрегирующие функции без
подзапросов, что уменьшает размер запроса( примеры, когда использование
подзапроса усложняет чтение запроса, будут немного дальше).</p>
<p>Помимо этого, вот еще два примера запросов с аналитическими функциями.</p>
<pre><code>select id,
       first_name,
       last_name,
       job,
       bd,
       exp,
       max(exp) over (order by first_name) max_exp_asc,
       max(exp) over (order by first_name desc) max_exp_desc
from employees emp
</code></pre>
<p><img src=/img/16_analytic/analytics_min_max_exp.png alt></p>
<p>Две колонки, <code>max_exp_asc</code> и <code>max_exp_desc</code>, считают максимальный стаж
среди сотрудников в порядке возрастания и убывания их имен
соответственно.</p>
<p>С простыми примерами аналитических функций мы познакомились, теперь
разберемся,как они работают.</p>
<h2 id=когда-агрегирующая-функция-становится-аналитической>Когда агрегирующая функция становится аналитической</h2>
<p>В первом примере агрегирующая функция <code>max</code> превратилась в аналитическую
после добавления к ней части <code>over()</code>. В итоге, было найдено
максимальное значение колонки <code>exp</code> среди всего набора данных, и это
значение было добавлено к каждой строке выборки, без группировки.</p>
<h2 id=подсчет-результатов-по-группам-partition-by>Подсчет результатов по группам. Partition by</h2>
<p>Для того, чтобы результаты считались по определенным группам, нужно
использовать конструкцию <code>partition by</code>, в которой нужно указать
колонки, по которым будет производиться вычисление.</p>
<pre><code>select emp.first_name,
       emp.last_name,
       emp.job,
       max(exp) over (partition by job) max_exp
from employees emp
</code></pre>
<p>В данном примере, который уже приводился раньше, максимальный стаж
вычисляется в отдельности для каждой из профессий, и затем добавляется к
каждой строке.</p>
<p>Посчитаем количество сотрудников по должностям и выведем отдельной
колонкой:</p>
<pre><code>select emp.first_name,
       emp.last_name,
       emp.job,
       count(*) over (partition by job) job_cnt
from employees emp
</code></pre>
<p><img src=/img/16_analytic/job_cnt_analytics.png alt></p>
<p>Результаты можно считать по нескольким группам. Выведем напротив каждого
сотрудника общее число сотрудников, родившихся в том же месяце(колонка
<code>mnth_cnt</code>) и количество сотрудников, родившихся в том же месяце и
занимающих такую же должность:</p>
<pre><code>select emp.id,
       emp.first_name,
       emp.last_name,
       emp.job,
       emp.bd,
       count(*) over(
           partition by extract(month from emp.bd)
       ) mnth_cnt,
       count(*) over (
           partition by extract(month from emp.bd), job
       ) mnth_cnt
from employees emp
</code></pre>
<p><img src=/img/16_analytic/partition_by_few.png alt></p>
<p>Всего есть три сотрудника, которые родились в одном и том же месяце -
июле. Поэтому в колонке <code>mnth_cnt</code> отображается число 3. В то же время,
есть лишь два сотрудника, которые родились в одном и том же месяце, и
при этом занимают одну и ту же должность - это сотрудники с id равными 2
и 3.</p>
<h2 id=порядок-вычисления-order-by>Порядок вычисления. Order by</h2>
<p>В аналитических функциях можно указывать порядок, в котором они будут
работать с итоговым набором данных. Для этого используется конструкция
<code>order by</code>.</p>
<p>Пронумеруем строки в нашей таблице в порядке возрастания и убывания дней
рождения сотрудников.</p>
<pre><code>select emp.id,
       emp.first_name,
       emp.last_name,
       emp.job,
       emp.bd,
       row_number() over (order by bd) bd_asc,
       row_number() over (order by bd desc) bd_desc
from employees emp
</code></pre>
<p><img src=/img/16_analytic/order_by_1.png alt></p>
<p>Функция <code>row_number</code> возможно является одной из самых часто используемых
аналитических функций. Она возвращает номер строки в итоговой выборке.
До ее появления в Oracle подобного функционала можно было достичь лишь
при использовании подзапросов и псевдостолбца <code>ROWNUM</code>.</p>
<p>Аналитические функции могут работать не только по группам или в
определенном порядке, но и в определенном порядке в пределах заданной
группы:</p>
<pre><code>select emp.id,
       emp.first_name,
       emp.last_name,
       emp.job,
       emp.bd,
       row_number() over (
           partition by job order by bd
       ) bd_asc,
       row_number() over (
           partition by job order by bd desc
       ) bd_desc
from employees emp
</code></pre>
<p><img src=/img/16_analytic/partitionby_orderby.png alt></p>
<p>Здесь нумерация производится отдельно для каждой группы. У двух
сотрудников с одинаковой должностью нумерация была проставлена в порядке
их дней рождения.</p>
<h2 id=диапазон-работы-аналитических-функций>Диапазон работы аналитических функций</h2>
<p>Аналитические функции всегда, явно или неявно, применяются к
определенному набору строк, называемому окном аналитической функции.</p>
<p>Не во всех аналитических функциях можно указывать окно. Среди самых
часто используемых функций, для которых можно указывать окно, находятся
<code>MIN</code>, <code>MAX</code>, <code>SUM</code>, <code>AVG</code>, <code>COUNT</code>, <code>LAST_VALUE</code>, <code>FIRST_VALUE</code> и
другие.</p>
<p>Чтобы примеры были немного более практичными, создадим еще одну таблицу,
в которой будем хранить данные о начисленных зарплатах сотрудникам по
месяцам:</p>
<pre><code>create table emp_salary(
    emp_id number not null,
    sal_date date not null,
    sal_value number not null,
    -- Начисления в данной таблице должны быть
    -- &quot;сбитыми&quot; по месяцам, и чтобы в данных не
    -- возникло ошибки, создаем уникальный ключ на
    -- поля с id сотрудника и месяцем начисления
    constraint emp_salary_uk unique(emp_id, sal_date)
);

comment on table emp_salary is
    'Зачисленные средства по месяцам';
comment on column emp_salary.emp_id is 
    'id сотрудника';
comment on column emp_salary.sal_date is 
    'Месяц начисления';
comment on column emp_salary.sal_value is 
    'Начисленные средства';

insert into emp_salary(emp_id, sal_date, sal_value)
values(1, to_date('01.01.2020', 'dd.mm.yyyy'), 1000);

insert into emp_salary(emp_id, sal_date, sal_value)
values(1, to_date('01.02.2020', 'dd.mm.yyyy'), 1320);

insert into emp_salary(emp_id, sal_date, sal_value)
values(1, to_date('01.03.2020', 'dd.mm.yyyy'), 850);


insert into emp_salary(emp_id, sal_date, sal_value)
values(2, to_date('01.01.2020', 'dd.mm.yyyy'), 1000);

insert into emp_salary(emp_id, sal_date, sal_value)
values(2, to_date('01.02.2020', 'dd.mm.yyyy'), 800);

insert into emp_salary(emp_id, sal_date, sal_value)
values(2, to_date('01.03.2020', 'dd.mm.yyyy'), 1200);


insert into emp_salary(emp_id, sal_date, sal_value)
values(3, to_date('01.01.2020', 'dd.mm.yyyy'), 1030);


insert into emp_salary(emp_id, sal_date, sal_value)
values(4, to_date('01.01.2020', 'dd.mm.yyyy'), 3700);
</code></pre>
<p>Общие данные выглядят следующим образом:</p>
<pre><code>select e.first_name,
       e.last_name,
       e.job,
       es.sal_date,
       es.sal_value
from emp_salary es
join employees e on e.id = es.emp_id
</code></pre>
<p><img src=/img/16_analytic/emp_sal.png alt></p>
<p>Теперь добавим колонку к выборке, которая будет показывать, как
изменялась минимальная заработная плата сотрудников с течением времени.</p>
<pre><code>select e.first_name,
       e.last_name,
       e.job,
       es.sal_date,
       es.sal_value,
       min(es.sal_value) over (
           order by sal_date
           rows between unbounded preceding and
               current row
       ) min
from emp_salary es
join employees e on e.id = es.emp_id
</code></pre>
<p><img src=/img/16_analytic/unb_preceding_1.png alt></p>
<p>Сейчас может показаться, что результат, который получился в запросе
такой же, как если бы мы и не задавали размер окна. Действительно, для
текущих данных запрос без добавления лишних ключевых слов выдает такой
же результат:</p>
<pre><code>select e.first_name,
       e.last_name,
       e.job,
       es.sal_date,
       es.sal_value,
       sum(es.sal_value) over (order by sal_date) min
from emp_salary es
join employees e on e.id = es.emp_id
</code></pre>
<p><img src=/img/16_analytic/unb_preceding_1.png alt></p>
<p>Чуть позже станет понятно, что это 2 совершенно разных запроса, а пока
разберем подробнее различные варианты указания окна в аналитических
функциях.</p>
<h2 id=строки-и-значения>Строки и значения</h2>
<p>Строки, которые определяют окно работы аналитической функции, можно
указывать физически, т.е. сказать БД: &ldquo;Для текущей строки в выборке
аналитическая функция должна обработать две строки перед ней и три
строки после нее&rdquo;; или: &ldquo;Для текущей строки в выборке аналитическая
функция должна обработать все строки начиная с текущей и заканчивая
всеми последующими строками&rdquo;.</p>
<p>Вторым возможным способом определения окна является определение не по
физическому расположению строки в выборке, а по значениям, которые
строки в себе содержат. Мысленно это можно произнести: &ldquo;Для текущей
строки в выборке аналитическая функция должна обработать те строки, в
которых значение колонки А будет больше, чем значение в колонке А
текущей строки&rdquo;; или: &ldquo;Для текущей строки в выборке аналитическая
функция должна обработать те строки, в которых значение колонки А будет
в пределах от 10 до 20 включительно&rdquo;.</p>
<p>В первом случае, при указании физических строк, используется ключевое
слово <code>ROWS</code>, во втором случае, при указании строк по их значениям,
используется ключевое слово <code>RANGE</code>.</p>
<h2 id=смещения-при-определении-окна>Смещения при определении окна</h2>
<p>Итак, при указании окна мы должны задать его верхнюю и нижнюю границу.</p>
<p>В общем виде указание границы выглядит следующим образом:</p>
<pre><code>(range или rows) between &quot;Верхняя граница&quot; and &quot;Нижняя граница&quot;
</code></pre>
<p>Теперь рассмотрим варианты для этих границ:</p>
<ul>
<li><code>UNBOUNDED PRECEDING</code> - указывает, что окно начинается с первой
строки в разделе. Может быть указано только для верхней границы, в
качестве нижней границы использовать нельзя.</li>
<li><code>UNBOUNDED FOLLOWING</code> - указывает, что окно заканчивается на
последней строке в разделе. Может быть указано только для нижней
границы.</li>
<li><code>CURRENT ROW</code> - обозначает текущую строку или значение. Может быть
использовано как для нижней границы, так и для верхней.</li>
<li><code>PRECEDING</code> - значение в строке или физическая строка, которая
предшествует текущей строке на</li>
<li><code>FOLLOWING</code> - значение в строке или физическая строка, которая
находится впереди текущей строки на</li>
</ul>
<p>Следует помнить, что если окно задается с использованием <code>ROWS</code>, т.е.
указываются строки, то и границы окна будут задаваться в строках, и
наоборот, если используется , то границы окна будут учитываться по
значениям в строках.</p>
<p>Если окно не указывается, то по-умолчанию оно имеет вид
<code>RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW</code>.</p>
<p>Теперь посмотрим на один из предыдущих запросов:</p>
<pre><code>select e.first_name,
       e.last_name,
       e.job,
       es.sal_date,
       es.sal_value,
       min(es.sal_value) over (
           order by sal_date
           rows between unbounded preceding
               and current row
       ) min
from emp_salary es
join employees e on e.id = es.emp_id
</code></pre>
<p>Рассмотрим, как будет работать аналитическая функция.</p>
<p><code>PARTITION BY</code> не указан, значит результаты будут &ldquo;сплошные&rdquo; и не будут
разбиваться по группам. Обрабатываться строки будут в порядке
возрастания даты в колонке <code>sal_date</code>, а диапазон строк, для которых
будет вычисляться функция, задается первой строкой во всем наборе данных
и заканчивается текущей строкой.</p>
<p>Теперь должна быть понятна разница между данным запросом и запросом без
указания окна, о которой говорилось в начале раздела - по-умолчанию окно
задается по значению, а мы установили размер окна со смещениями в
строках.</p>
<p>Еще один важный момент: значения в колонке <code>sal_date</code> не являются
уникальными. Это означает, что результат будет недетерминированным, т.е.
может отличаться от запуска к запуску, т.к. порядок следования строк в
выборке может измениться.</p>
<p>Чтобы избавиться от такого эффекта, можно добавить еще одну колонку в
конструкцию order by, чтобы сделать порядок следования строк уникальным
и не меняющимся. В данном случае мы можем дополнительно сортировать
данные по id сотрудника:</p>
<pre><code>min(es.sal_value) over (
    order by sal_date, id
    rows between unbounded preceding 
        and current row
) min
</code></pre>
<p>В общем, когда несколько колонок имеют одинаковые значения,
аналитические функции работают по определенным правилам:</p>
<ul>
<li>Функции <code>CUME_DIST</code>, <code>DENSE_RANK</code>, <code>NTILE</code>, <code>PERCENT_RANK</code> и <code>RANK</code>
возвращают одинаковый результат для всех строк</li>
<li>Функция <code>ROW_NUMBER</code> присвоит каждой строке уникальное значение.
Порядок присваивания будет зависеть от порядка обработки строк БД,
который мы не можем предугадать</li>
<li>Все остальные функции будут работать по-разному в зависимости от
спецификации окна. Если окно задавалось при помощи <code>RANGE</code>, то
функция вернет одинаковое значение для всех строк. Если
использовалось ключевое слово <code>ROWS</code>, то результат нельзя будет
предугадать - он опять же будет зависеть от порядка обработки строк
базой данных, который может отличаться для одного и того же набора
данных от запуска к запуску.</li>
</ul>
<p>Размеры окна можно задавать в виде смещений:</p>
<pre><code>select e.first_name,
       e.last_name,
       e.job,
       es.sal_date,
       es.sal_value,
       round(
           avg(es.sal_value)over (
               order by sal_date, id
               rows between 2 preceding and current row
           ),
       2) avg_sal
from emp_salary es
join employees e on e.id = es.emp_id
</code></pre>
<p><img src=/img/16_analytic/rows_2_preceding_curr_row.png alt></p>
<p>Здесь в колонке avg_sal считается средняя заработная плата по трем
строкам - двум предшествующим и текущей. Порядок следования, как мы
помним, задается при помощи ORDER BY, поэтому две предшествующие строки</p>
<ul>
<li>это строки, у которых значение в колонках sal_date будет меньше либо
равным значению в текущей строке.</li>
</ul>
<p>Значение функции округляется до двух знаков после запятой при помощи
функции <code>round</code>. Аналитическая функция берется в скобки полностью,
начиная от имени функции и заканчивая определением окна. К значениям,
полученным при помощи аналитических функций можно применять другие
функции или операторы - например, можно было бы добавить 100 к среднему
значению:</p>
<pre><code>avg(es.sal_value)over (
    order by sal_date
    rows between 2 preceding and current row
) + 100 avg_sal
</code></pre>
<p>Или даже получить разность между значениями двух аналитических функций:</p>
<pre><code>max(es.sal_value)
    over (
        order by sal_date
        range between 1 preceding and current row
    ) -
min(es.sal_value)
    over (
        order by sal_date
        rows between 1 preceding and current row
    )
</code></pre>
<p>В следующем примере смещение задается не в строках, а в диапазоне
значений, которые содержит колонка sal_value:</p>
<pre><code>select e.first_name,
       e.last_name,
       e.job,
       es.sal_date,
       es.sal_value,
       sum(es.sal_value) over (
           order by sal_value
           range between 1000 preceding and current row
       ) max_sal
from emp_salary es
join employees e on e.id = es.emp_id
</code></pre>
<p><img src=/img/16_analytic/preceding_range_1.png alt></p>
<p>Т.к. использовался <code>RANGE</code>, то сумма рассчитывается для всех строк,
значение которых находится в диапазоне от 1000 до значения в текущей
строке.</p>
<p>Еще раз, следует обратить внимание, что строки, которые находятся после
текущей, также обрабатываются функцией, если значение колонки sal_value
входит в заданный диапазон. Это можно видеть на изображении выше, в
строках, где значение sal_value равно 1000 - для первой строки в сумму
посчиталось и значение следующей.</p>
<p>Следующий пример считает сумму по четырем строкам - в окно входят 2
предшествующие строки, текущая строка и одна строка, следующая за
текущей:</p>
<pre><code>select e.first_name,
       e.last_name,
       e.job,
       es.sal_date,
       es.sal_value,
       sum(es.sal_value) over (
           order by sal_value
           rows between 2 preceding and 1 following
       ) sum_sal
from emp_salary es
join employees e on e.id = es.emp_id
</code></pre>
<p><img src=/img/16_analytic/sum_rows_3.png alt></p>
<p>Т.к. окно задавалось с использованием <code>ROWS</code>, сумма считается именно по
строкам, а не по их значениям. Для первой строки в сумму были взяты
данные из нее самой и следующей, т.к. предыдущих строк у нее нет. Для
второй строки была лишь одна предыдущая строка, а у последней не было
следующей.</p>
<h2 id=ограничения-на-order-by>Ограничения на ORDER BY</h2>
<p>ORDER BY в аналитических функциях может использоваться только с одной
колонкой, за исплючением случаев, когда используется <code>RANGE</code> и окно
задается одним из следующих способов:</p>
<ul>
<li><code>RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW</code></li>
<li><code>RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING</code></li>
<li><code>RANGE BETWEEN CURRENT ROW AND CURRENT ROW</code></li>
<li><code>RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING</code></li>
</ul>
<nav class="pagination mb-3">
<ul class=pagination-list>
<li class=pagination-item>
<a href=http://orasql.ru/sql/standfunc/datefunctions/ class="pagination-link pagination-prev"> &lt; Работа с датами в Oracle </a>
</li>
</ul>
</nav>
</div>
<footer class="footer b-dark-low b-top">
<div class="footer-container container centered edges">
<div class="footer-body mt-10">
<nav class="nav nav-muted nav-menu-sm"><ul class=nav-list>
<li class=nav-item><a href=/ class=nav-link>Orasql.ru</a></li>
<li class=nav-item><a href=/ class=nav-link>Учебник</a></li>
<li class=nav-item><p class="text-medium text-moderated">Email: orasqlru@gmail.com</p></li>
</ul>
</nav>
</div>
<div class="footer-copy mt-6 pt-6 b-dark-7 b-top">
<p class="text-medium text-moderated">© Orasql.ru <br> 2019-2021</p>
</div>
</div>
</footer>
</body>
</html>