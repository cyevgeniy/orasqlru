<!doctype html><html><head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<link rel=stylesheet href=/css/superkube.min.css>
<link rel=stylesheet href=/css/main.css>
<title>Учебник Oracle SQL, PL/SQL | Древовидные структуры данных. Рекурсивные запросы</title>
</head>
<body><div class="navbar bg-dark mb-10">
<div class="navbar-container container edges centered">
<div class=navbar-brand>
<a href=/ class=brand>
Orasql.ru
</a>
</div>
<div class="navbar-nav ml-6">
<nav class="nav nav-light nav-semibold">
<ul class=nav-list>
<li class=nav-item><a href=/orasqlru/book/ class=nav-link>Книга</a></li>
</ul>
</nav>
<nav class="nav nav-light nav-semibold">
<ul class=nav-list>
<li class=nav-item><a href=https://github.com/cyevgeniy/orasqlru class=nav-link>Github</a></li>
</ul>
</nav>
</div>
</div>
</div>
<div id=container class="container-medium edges centered">
<div class="doc-head mb-4 container-10">
<h5 class="heading-micro heading-muted">Основы</h5>
<h1 class="heading-huge heading-heavy">Древовидные структуры данных. Рекурсивные запросы</h1>
</div>
<div class="doc-toc mt-6 mb-6">
<nav class="menu menu-underline menu-medium menu-numbered">
<ul class=menu-list>
<li class=menu-item>
<a href=#%d1%80%d0%b5%d0%b0%d0%bb%d0%b8%d0%b7%d0%b0%d1%86%d0%b8%d1%8f-%d0%b4%d1%80%d0%b5%d0%b2%d0%be%d0%b2%d0%b8%d0%b4%d0%bd%d1%8b%d1%85-%d1%81%d1%82%d1%80%d1%83%d0%ba%d1%82%d1%83%d1%80-%d0%b2-%d1%80%d1%81%d1%83%d0%b1%d0%b4 class=menu-link>Реализация древовидных структур в РСУБД</a>
</li><li class=menu-item>
<a href=#connect-by class=menu-link>Connect by</a>
</li><li class=menu-item>
<a href=#%d0%bf%d1%81%d0%b5%d0%b2%d0%b4%d0%be%d1%81%d1%82%d0%be%d0%bb%d0%b1%d0%b5%d1%86-level class=menu-link>Псевдостолбец level</a>
</li><li class=menu-item>
<a href=#%d0%bf%d1%81%d0%b5%d0%b2%d0%b4%d0%be%d1%81%d1%82%d0%be%d0%bb%d0%b1%d0%b5%d1%86-connect_by_isleaf class=menu-link>Псевдостолбец CONNECT_BY_ISLEAF</a>
</li><li class=menu-item>
<a href=#%d1%81%d0%be%d1%80%d1%82%d0%b8%d1%80%d0%be%d0%b2%d0%ba%d0%b0-%d0%b2-%d1%80%d0%b5%d0%ba%d1%83%d1%80%d1%81%d0%b8%d0%b2%d0%bd%d1%8b%d1%85-%d0%b7%d0%b0%d0%bf%d1%80%d0%be%d1%81%d0%b0%d1%85 class=menu-link>Сортировка в рекурсивных запросах</a>
</li><li class=menu-item>
<a href=#%d0%bd%d0%b0%d1%80%d1%83%d1%88%d0%b5%d0%bd%d0%b8%d0%b5-%d0%b4%d1%80%d0%b5%d0%b2%d0%be%d0%b2%d0%b8%d0%b4%d0%bd%d0%be%d0%b9-%d1%81%d1%82%d1%80%d1%83%d0%ba%d1%82%d1%83%d1%80%d1%8b-%d0%bf%d1%80%d0%b8-%d0%b2%d1%8b%d0%b1%d0%be%d1%80%d0%ba%d0%b5 class=menu-link>Нарушение древовидной структуры при выборке</a>
</li></ul></nav>
</div>
<p>Достаточно часто приходится иметь дело с древовидными структурами
данных. Классическим примером является структура подразделений
организации, где один отдел является частью другого, и при этом также
состоит из нескольких подразделений. Также можно в виде дерева описать
отношения между сотрудниками - кто кому приходится начальником; некий
список документов, где один документ появляется на основании другого, а
тот в свою очередь был создан на основании третьего, и т.п.</p>
<h2 id=реализация-древовидных-структур-в-рсубд>Реализация древовидных структур в РСУБД</h2>
<p>Для того, чтобы можно было листья дерева собрать воедино, нужно знать,
как они соотносятся друг с другом. Как правило, все данные, которые
нужно хранить в виде дерева, хранятся в одной таблице. Для того, чтобы
по определенной строке определить ее родителя, в таблицу добавляется
колонка, которая ссылается на родителя в этой же таблице. У корневого
узла в дереве колонка с id родительского узла остается пустой.</p>
<p>Для разбора создадим таблицу, которая будет содержать список
подразделений.</p>
<pre><code>create table departments(
id number primary key,
dept_name varchar2(100),
parent_id number,
constraint departments_parent_id_fk foreign key(parent_id)
references departments(id));

comment on table departments is 'Подразделения';

comment on column departments.parent_id is
'Ссылка на родительский узел';

insert into departments values(1, 'ЗАО ИнвестКорп', null);
insert into departments values(2, 'Бухгалтерия', 1);
insert into departments values(3, 'Отдел продаж', 1);
insert into departments values(4, 'IT-отдел', 1);
insert into departments values(5, 'Дирекция', 1);
insert into departments values(6, 'Бухгалтерия по участку 1', 2);
insert into departments values(7, 'Бухгалтерия по участку 2', 2);
insert into departments values(8, 'Отдел QA', 4);
insert into departments values(9, 'Отдел разработки', 4);
</code></pre>
<h2 id=connect-by>Connect by</h2>
<p>Oracle имеет свой собственный синтаксис для написания рекурсивных
запросов. Сначала пример:</p>
<pre><code>select d.*
from departments d
start with d.id = 1
connect by prior id = d.parent_id
</code></pre>
<p><img src=/img/6_recursive/simple_example.png alt></p>
<p>Данный запрос проходит по дереву вниз начиная с узла, имеющего <code>id = 1</code>.</p>
<p><code>connect by</code> задает правило, по которому дерево будет обходиться. В
данном примере мы указываем, что у строк, которые должны будут
выбираться на следующем шаге, значение столбца <code>parent_id</code> должно быть
таким же, как значение столбца <code>id</code> на текущем.</p>
<p>В конструкции <code>start with</code> не обязательно указывать некие значения для
<code>id</code> строк. Там можно указывать любое выражение. Те строки, для которых
оно будет истинным, и будут являть собой стартовые узлы в выборке.</p>
<h2 id=псевдостолбец-level>Псевдостолбец level</h2>
<p>При использовании рекурсивных запросов, написанных с использованием
<code>connect by</code>, становится доступен такой псевдостолбец, как <code>level</code>. Этот
псевдостолбец возвращает 1 для корневых узлов в дереве, 2 для их
дочерних узлов и т.д.</p>
<pre><code>select dp.*, level
from departments dp
start with dp.parent_id is null
connect by prior id = dp.parent_id
</code></pre>
<p><img src=/img/6_recursive/level_example.png alt></p>
<p>В приведенном выше примере мы начинаем строить наше дерево с корневых
узлов, не зная их конкретных <code>id</code>. Но мы знаем, что у корневых узлов нет
родителей, что и указали в конструкции <code>start with</code> -
<code>parent_id is null</code>. В этом случае корневые узлы дерева, которое вернет
запрос, будут совпадать с корневыми узлами дерева, которое хранится в
БД.</p>
<p>Можно, например, используя <code>level</code>, вывести дерево в более красивом
виде:</p>
<pre><code>select lpad(dp.dept_name, length(dp.dept_name) + (level * 4) - 4, ' ') dept_name, level
from departments dp
start with dp.parent_id is null
connect by prior id = dp.parent_id
</code></pre>
<p><img src=/img/6_recursive/level_pretty.png alt></p>
<p>Здесь используется функция <code>lpad</code>, которая дополняет передаваемую
строку(наименование подразделения) до определенной длины(длина
наименования + уровень вложенности * 4) пробелами слева. Кстати,
функция <code>rpad</code> работает так же, только дополняет символы справа.</p>
<h2 id=псевдостолбец-connect_by_isleaf>Псевдостолбец CONNECT_BY_ISLEAF</h2>
<p>Данный псевдостолбец вернет 1 в том случае, когда у узла в дереве больше
нет потомков, и 0 в противном случае.</p>
<pre><code>select dp.dept_name, CONNECT_BY_ISLEAF
from departments dp
start with dp.parent_id is null
connect by prior id = dp.parent_id
</code></pre>
<p><img src=/img/6_recursive/connect_by_isleaf.png alt></p>
<h2 id=сортировка-в-рекурсивных-запросах>Сортировка в рекурсивных запросах</h2>
<p>В запросах с использованием <code>CONNECT BY</code> нельзя использовать <code>ORDER BY</code>
и <code>GROUP BY</code>, т.к. они нарушат древовидную структуру.</p>
<p>Это можно увидеть на примере:</p>
<pre><code>select dp.dept_name, level
from departments dp
start with dp.parent_id is null
connect by prior id = dp.parent_id
order by dp.dept_name asc
</code></pre>
<p><img src=/img/6_recursive/order_by_wrong.png alt></p>
<p>Как видно, корневой узел теперь шестой в выборке, а на первом месте
подразделение, которое находится на втором уровне вложенности в дереве.</p>
<p>Для того, чтобы отсортировать данные, не нарушая их древовидной
структуры, используется конструкция <code>ORDER SIBLINGS BY</code>. В этом случае
сортировка будет применяться отдельно для каждой группы потомков в
дереве:</p>
<p><img src=/img/6_recursive/order_siblings_by.png alt></p>
<p>Теперь узлы, находящиеся на одном уровне, сортируются в алфавитном
порядке, при этом структура дерева не нарушена.</p>
<h2 id=нарушение-древовидной-структуры-при-выборке>Нарушение древовидной структуры при выборке</h2>
<p>Предположим, что мы хотим получить структуру подразделений начиная с
тех, чьи названия содержат в себе слово &ldquo;отдел&rdquo;:</p>
<pre><code>select *
from departments
start with upper(dept_name) like upper('%Отдел%')
connect by prior id = parent_id
</code></pre>
<p><img src=/img/6_recursive/wrong_tree_1.png alt></p>
<p>Некоторые строки дублируются, хотя в таблице имена подразделений не
повторяются.</p>
<p>Теперь выполним тот же запрос, только добавим к списку колонок
псевдостолбец <code>level</code>:</p>
<pre><code>select id, dept_name, parent_id, level
from departments
start with upper(dept_name) like upper('%Отдел%')
connect by prior id = parent_id
</code></pre>
<p><img src=/img/6_recursive/wrong_tree_2.png alt></p>
<p>Теперь понятно, что строки дублируются из-за того, что они находятся на
разных уровнях в дереве.</p>
<p>Разберем, почему так происходит, пройдя путь построения дерева:</p>
<ol>
<li>В качестве корней дерева добавляются узлы, которые удовлетворяют
условию, находящемуся в <code>START WITH</code>. Это &ldquo;Отдел продаж&rdquo;,
&ldquo;IT-отдел&rdquo;, &ldquo;Отдел QA&rdquo; и &ldquo;Отдел разработки&rdquo;. Все они находятся на
первом уровне вложенности в дереве.</li>
<li>Рекурсивно ищем потомков для всех выбранных на первом шаге узлов. Из
всех них вложенность есть только у отдела IT - и внутри него как раз
находятся &ldquo;Отдел QA&rdquo; и &ldquo;Отдел разработки&rdquo;, поэтому они добавляются
со вторым уровнем вложенности.</li>
</ol>
<p>Следует различать фактическое дерево, которое хранится в таблице, и то,
которое получается при выборке, так как они могут не совпадать. На
практике такая необходимость почти не встречается, и если при выборке
данные не отражают той структуры, которая хранится в БД, то скорее всего
запрос написан с ошибкой.</p>
<nav class="pagination mb-3">
<ul class=pagination-list>
<li class=pagination-item>
<a href=https://cyevgeniy.github.io/orasqlru/sql/basics/joins/ class="pagination-link pagination-prev"> &lt; Соединения таблиц </a>
</li>
<li class="pagination-item ml-auto">
<a href=https://cyevgeniy.github.io/orasqlru/sql/basics/subqueries/ class="pagination-link pagination-next"> Подзапросы в Oracle > </a>
</li>
</ul>
</nav>
</div>
<footer class="footer b-dark-low b-top">
<div class="footer-container container centered edges">
<div class="footer-body mt-10">
<nav class="nav nav-muted nav-menu-sm"><ul class=nav-list>
<li class=nav-item><a href=/ class=nav-link>Orasql.ru</a></li>
<li class=nav-item><a href=/ class=nav-link>Учебник</a></li>
<li class=nav-item><p class="text-medium text-moderated">Email: orasqlru@gmail.com</p></li>
</ul>
</nav>
</div>
<div class="footer-copy mt-6 pt-6 b-dark-7 b-top">
<p class="text-medium text-moderated">© Orasql.ru <br> 2019-2021</p>
</div>
</div>
</footer>
</body>
</html>