<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Основы on Учебник Oracle SQL, PL/SQL</title><link>http://orasql.ru/sql/basics/</link><description>Recent content in Основы on Учебник Oracle SQL, PL/SQL</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="http://orasql.ru/sql/basics/index.xml" rel="self" type="application/rss+xml"/><item><title>Таблицы</title><link>http://orasql.ru/sql/basics/tables/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/sql/basics/tables/</guid><description>Данные в реляционных базах данных хранятся в таблицах. Таблицы - это ключевой объект, с которыми придется работать в SQL.
Таблицы в БД совсем не отличаются от тех таблиц, с которыми все уже знакомы со школы - они состоят из колонок и строк.
Каждая колонка в таблице имеет своё имя и свой тип, т.е. тип данных, которые будут в ней содержаться. Помимо типа данных для колонки можно указать максимальный размер данных, которые могут содержаться в этой таблице.</description></item><item><title>Основные типы данных</title><link>http://orasql.ru/sql/basics/maintypes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/sql/basics/maintypes/</guid><description>Таблицы могут содержать не только строки. Рассмотрим основные типы данных в БД Oracle.
Varchar2 Строковый тип. При создании таблицы всегда нужно указывать размер строки. Размер может указываться в байтах либо в символах. По-умолчанию максимальный размер строки равен 4000 байт, либо 4000 символов. Этот размер может быть изменен дополнительной настройкой БД.
country(100);-- строка из 100 байт country(100 char); -- строка из 100 символов Number Числовой тип данных. Используется для хранения как целых чисел, так и дробных чисел.</description></item><item><title>Пример SELECT запроса</title><link>http://orasql.ru/sql/basics/selectstruct/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/sql/basics/selectstruct/</guid><description>Рассмотрим простой SQL запрос:
-- данные, которые мы извлекаем select emp.name, emp.last_name, emp.age, dept.name from employees emp join departments dept on dept.id = emp.department_id -- соединение where (emp.id = 10 and emp.age &amp;gt; 25) -- условие выборки order by name desc -- сортировка Конечно, запрос может выглядеть и по-другому, но в целом данный пример раскрывает большую часть из структуры SELECT запроса.
Порядок выполнения Очень важно понимать, в каком порядке выполняется запрос.</description></item><item><title>Написание SQL- кода</title><link>http://orasql.ru/sql/basics/scripts/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/sql/basics/scripts/</guid><description>Код SQL, как и любой другой, можно сохранять в файлы. Расширение этих файлов на самом деле не имеет значения, но принято сохранять sql-скрипты с расширением .sql.
Некоторые IDE могут сохранять SQL-код и с другими расширениями файлов(например PL/SQL Developer - для т.н. тестовых скриптов он использует расширение *.tst.
Комментарии В SQL можно и нужно добавлять комментарии. Это участки текста, предназначенные для чтения другими людьми, и которые не обрабатываются базой данных.
Комментарий может быть однострочным:</description></item><item><title>Сортировка результатов. Order by</title><link>http://orasql.ru/sql/basics/orderby/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/sql/basics/orderby/</guid><description>При выборке данных из БД мы можем сортировать извлекаемые данные в нужном нам порядке. Использование сортировки поможет сделать получаемые данные более удобочитаемыми и воспринимаемыми для анализа человеком.
Подготовка тестовых данных Создадим таблицу, которая будет содержать список блюд ресторана:
create table dishes( name varchar2(100) not null, price number(5,2) not null, rating number(5) ); comment on column dishes.name is 'Наименование блюда'; comment on column dishes.price is 'Стоимость за одну порцию'; comment on column dishes.</description></item><item><title>Оператор WHERE. Операторы сравнения</title><link>http://orasql.ru/sql/basics/comparison/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/sql/basics/comparison/</guid><description>Использование оператора where позволяет добавить фильтр на те данные, которые будет обрабатывать sql, будь то выборка, вставка, обновление или удаление.
Для демонстрации будем использовать те же данные, что и в примере с order by :
create table dishes( name varchar2(100) not null, price number(5,2) not null, rating number(5) ); comment on column dishes.name is 'Наименование блюда'; comment on column dishes.price is 'Стоимость за одну порцию'; comment on column dishes.rating is 'Популярность блюда'; insert into dishes(name, price, rating) values ('Макароны с сыром', 20.</description></item><item><title>Проверка нескольких условий. AND, OR</title><link>http://orasql.ru/sql/basics/andor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/sql/basics/andor/</guid><description>При выборке данных мы можем указывать несколько условий одновременно. Для объединения условий можно использовать операторы and (логическое &amp;ldquo;И&amp;rdquo;) и or(логическое &amp;ldquo;ИЛИ&amp;rdquo;). Разберем каждый из них на примерах.
Пример №1: получим список блюд с рейтингом, меньшим чем 320, но со стоимостью большей, чем 2:
select * from dishes where rating &amp;lt; 320 and price &amp;gt; 2 Пример №2: получим список блюд, рейтинг которых варьируется от 280 до 320 включительно, и цена которых меньше 30:</description></item><item><title>Проверка значения на NULL</title><link>http://orasql.ru/sql/basics/isnull/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/sql/basics/isnull/</guid><description>Если обратить внимание на результаты запросов, выше, то можно заметить, что строка, содержащая NULL в колонке rating не была возвращена ни одним из них.
Как уже говорилось ранее, NULL - это отсутствие значения. Соответственно, он и не может быть больше, меньше, либо даже равняться какому-либо значению, даже себе.
Например, следующий запрос не вернет ни одной строки, хотя мы вроде как и указываем в запросе необходимый критерий - равенство NULL:
select d.</description></item><item><title>IN, NOT IN</title><link>http://orasql.ru/sql/basics/innotin/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/sql/basics/innotin/</guid><description>Вхождение в набор данных. IN Условие IN позволяет ответить на следующий вопрос: &amp;ldquo;Входит ( IN ) ли значение в заданный набор данных?&amp;rdquo;.
Следующий пример вернет все блюда, рейтинг которых равен 320 либо 270:
select d.* from dishes d where d.rating IN (320, 270) Использовать можно любые типы, не только числа:
select d.* from dishes d where d.name IN ('Макароны с сыром', 'Овощной салат', 'Борщ') Следует помнить, что при сравнении строк учитывается регистр, т.</description></item><item><title>Вхождение в диапазон. BETWEEN. NOT BETWEEN</title><link>http://orasql.ru/sql/basics/between/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/sql/basics/between/</guid><description>BETWEEN используется для того, чтобы проверить значение на вхождение в диапазон. Проверять вхождение в диапазон значений можно строки, числа и даты.
Пример №1: Получить список блюд, рейтинг которых колеблется от 270 до 320 включительно:
select d.* from dishes d where rating between 270 and 320 Следует помнить, что граничные значения диапазона всегда включаются при проверке, т.е. этот запрос идентичен следующему:
select d.* from dishes d where d.rating ≥ 270 and d.</description></item><item><title>Соединения таблиц</title><link>http://orasql.ru/sql/basics/joins/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/sql/basics/joins/</guid><description>Работать с одной таблицей в БД приходится редко. Как правило, данные распределены по нескольким таблицам, которые связаны между собой.
Подготовка данных Для демонстрации соединений понадобится несколько таблиц.
create table app_users( login varchar2(50 char) primary key, registration_date date default sysdate not null, email varchar2(200 char) not null ); comment on table app_users is 'Пользователи'; create table app_roles( role_id number(10) primary key, role_name varchar2(50) not null ); comment on table app_roles is 'Роли в системе'; create table user_roles( login varchar2(50 char) not null, role_id number(10) not null, constraint user_roles_login_fk foreign key(login) references app_users(login), constraint user_roles_role_id_fk foreign key(role_id) references app_roles(role_id) ); insert into app_users values('johndoe', sysdate, 'johndoe@johndoemail.</description></item><item><title>Древовидные структуры данных. Рекурсивные запросы</title><link>http://orasql.ru/sql/basics/recursive/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/sql/basics/recursive/</guid><description>Достаточно часто приходится иметь дело с древовидными структурами данных. Классическим примером является структура подразделений организации, где один отдел является частью другого, и при этом также состоит из нескольких подразделений. Также можно в виде дерева описать отношения между сотрудниками - кто кому приходится начальником; некий список документов, где один документ появляется на основании другого, а тот в свою очередь был создан на основании третьего, и т.п.
Реализация древовидных структур в РСУБД Для того, чтобы можно было листья дерева собрать воедино, нужно знать, как они соотносятся друг с другом.</description></item><item><title>Подзапросы в Oracle</title><link>http://orasql.ru/sql/basics/subqueries/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/sql/basics/subqueries/</guid><description>Подзапросы представляют собой обычные SQL-запросы, которые являются частью другого SQL-запроса.
Подзапросы - важная часть в изучении SQL. Некоторые данные просто не могут быть получены, если их не использовать. Далее будут рассмотрены примеры использования подзапросов в Oracle.
Подготовка тестовых данных create table books( book_id number primary key, book_name varchar2(200) not null, author varchar2(50 char) not null, release_year number not null ); create table book_orders( book_id number not null, quantity number(2) not null, order_date date not null ); comment on table books is 'Книги'; comment on table book_orders is 'Статистика продаж за день'; insert into books values(1, 'Властелин колец', 'Толкин', 1954); insert into books values(2, 'Гордость и предубеждение', 'Джейн Остин', 1813); insert into books values(3, 'Тёмные начала', 'Филип Пулман', 1995); insert into books values(4, 'Автостопом по галактике', 'Дуглас Адамс', 1979); insert into book_orders values(1, 1, to_date('31.</description></item><item><title>Exists. Наличие строк в подзапросе</title><link>http://orasql.ru/sql/basics/exists/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/sql/basics/exists/</guid><description>Оператор EXISTS имеет вид EXISTS(подзапрос), и возвращает истинное значение в том случае, если подзапрос в скобках возвращает хотя бы одну строку. Может использоваться с оператором NOT.
Примеры будем разбирать на данных из части про подзапросы.
Пример №1: Получить список книг, которые заказывались хотя бы раз.
Очевидно что ответом будут те книги, ссылки на которые есть в таблице book_orders. Нас устроит любая книга, которая имеет хотя бы один заказ, и поэтому задача легко решается с использованием EXISTS:</description></item><item><title>Subquery factoring. WITH</title><link>http://orasql.ru/sql/basics/with/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://orasql.ru/sql/basics/with/</guid><description>Часть WITH SQL запроса используется для реализации так называемого Subquery factoring. Эта возможность позволяет задать подзапрос, который будет доступен в любом месте SQL запроса. Subquery factoring в некоторых случаях значительно упрощает чтение и написание запросов. Более того, велика вероятность того, что при использовании subquery factoring БД построит более оптимальный план выполнения запроса.
Используя Subquery factoring, вы говорите БД о том, что указанный подзапрос вероятно будет использоваться несколько раз в одном запросе, и БД сможет предпринять действия, чтобы более эффективно повторно использовать его.</description></item></channel></rss>