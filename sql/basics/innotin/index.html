<!doctype html><html><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href=/css/design.css><link rel=stylesheet href=/css/layout.css><link rel=stylesheet href=/css/base.css><link rel=stylesheet href=/css/navigation.css><script async src="https://www.googletagmanager.com/gtag/js?id=UA-144211477-1"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","UA-144211477-1")</script><title>Учебник Oracle SQL, PL/SQL | IN, NOT IN</title></head><body><div class=menu><a href=/ class=menu__item>Orasql.ru</a>
<a href=/#sql class=menu__item>Учебник Oracle SQL</a>
<a href=/#plsql class=menu__item>Учебник PL/SQL</a></div><div class=content><h1>IN, NOT IN</h1><h2 id=вхождение-в-набор-данных-in>Вхождение в набор данных. IN</h2><p>Условие <code>IN</code> позволяет ответить на следующий вопрос: &ldquo;Входит ( IN ) ли
значение в заданный набор данных?&rdquo;.</p><p>Следующий пример вернет все блюда, рейтинг которых равен 320 либо 270:</p><pre><code>select d.*
from dishes d
where d.rating IN (320, 270)
</code></pre><p><img src=/img/3_select/rating_in_320_270.png alt></p><p>Использовать можно любые типы, не только числа:</p><pre><code>select d.*
from dishes d
where d.name IN 
    ('Макароны с сыром', 'Овощной салат', 'Борщ')
</code></pre><p><img src=/img/3_select/dishes_name_in.png alt></p><p>Следует помнить, что при сравнении строк учитывается регистр, т.е.
cледующий запрос:</p><pre><code>select d.*
from dishes d
where d.name IN
    ('Макароны с сыром', 'ОВОЩНОЙ салат', 'БОРЩ')
</code></pre><p>Не вернет строки с овощным салатом и борщом:</p><p><img src=/img/3_select/name_in_casesensitive.png alt></p><p>Можно попробовать поправить ситуацию и воспользоваться уже знакомой
функцией <code>UPPER</code>. Напомним, что эта функция приводит строку к верхнему
регистру:</p><pre><code>select d.*
from dishes d
where UPPER(d.name) IN
    ('Макароны с сыром', 'ОВОЩНОЙ салат', 'БОРЩ')
</code></pre><p><img src=/img/3_select/name_in_upper_borsch.png alt></p><p>Итак, следующим запросом мы фактически сказали БД: &ldquo;Покажи нам все
строки из таблицы dishes, в которых наименование, написанное большими
буквами, будет равно либо &ldquo;Макароны с сыром&rdquo;, либо &ldquo;ОВОЩНОЙ салат&rdquo;, либо
&ldquo;БОРЩ&rdquo;.</p><p>Почему в выборку не попали макароны с сыром и овощной салат? Ответ прост</p><ul><li>строка &ldquo;МАКАРОНЫ С СЫРОМ&rdquo; не идентична строке &ldquo;Макароны с сыром&rdquo;, как
и строка &ldquo;ОВОЩНОЙ САЛАТ&rdquo; не идентична строке &ldquo;ОВОЩНОЙ салат&rdquo;.</li></ul><p>Как же можно получить все три интересующих нас блюда, не переживая за
то, что регистры строк(а здесь достаточно несовпадения и хотя бы в одном
символе) в таблице <code>dishes</code> не совпадут с регистрами строк, которые мы
перечисляем в выражении <code>IN</code>?</p><p>Ответ прост - привести к верхнему/нижнему регистру как строки в таблице,
так и строки в выражении <code>IN</code>.</p><p>Следующий запрос выдаст список всех интересующих нас блюд:</p><pre><code>select d.*
from dishes d
where UPPER(d.name) IN (
    upper('Макароны с сыром'),
    upper('ОВОЩНОЙ салат'),
    upper('БОРЩ')
)
</code></pre><p><img src=/img/3_select/dishes_name_in.png alt></p><h2 id=отсутствие-в-наборе-данных-not-in>Отсутствие в наборе данных. NOT IN</h2><p>Условие <code>NOT IN</code> выполняет функцию, противоположную выражению <code>IN</code>:
убедиться, что значение не входит в указанный набор данных.</p><p>Например, нам требуется получить список блюд, за исключением чая с
молоком и овощного салата:</p><pre><code>select *
from dishes
where name not in ('Овощной салат', 'Чай с молоком')
</code></pre><p>Получим следующий результат:</p><p><img src=/img/3_select/not_in_tea_s.png alt></p><p>Для понимания того, как работает конструкция NOT IN, лучше рассматривать
приведенный пример как следующий, эквивалентный запрос:</p><pre><code>select *
from dishes
where name &lt;&gt; 'Овощной салат'
and name &lt;&gt; 'Чай с молоком'
</code></pre><p>При использовании <code>NOT IN</code>, проверяемое значение будет поочередно
сравнено с каждым из значений, перечисленных в скобках после <code>NOT IN</code>, и
если хотя бы одно сравнение не будет истинным, то все условие будет
считаться ложным.</p><p>Если в списке значений <code>NOT IN</code> будет присутствовать хотя бы одно
<code>NULL</code>-значение, то условие будет ложным для всех обрабатываемых строк,
даже тех, где проверяемое значение является <code>NULL</code>.</p><p>Рассмотрим это на примере.</p><p>Предположим, мы хотим получить список блюд, рейтинг которых не 320 и не
NULL. Для этого мы написали следующий запрос:</p><pre><code>select *
from dishes
where rating not in (320, null)
</code></pre><p><img src=/img/3_select/no_data_found.png alt></p><p>Результат получился немного не таким, как хотелось бы. Чтобы
понять, почему не было получено никаких данных, рассмотрим, как
работает данный запрос:</p><pre><code>select *
from dishes
where rating &lt;&gt; 320
and rating &lt;&gt; null
</code></pre><p>Теперь все должно быть более понятным. Причина кроется в выражении
<code>rating &lt;> null</code>. Сравнение с <code>NULL</code> всегда
дает ложный результат, а так как используется логическое И(and), то и
результат всего выражения WHERE будет ложным.</p><p>Поэтому, используя <code>NOT IN</code>, всегда следует убедиться в отсутствии
null-значений.</p></div><footer class="footer b-dark-low b-top"><div class="footer-container container centered edges"><p class="text-medium text-moderated">© Orasql.ru<br>2019-2023</p></div></div></footer></body></html>