<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Работа с множествами on Учебник Oracle SQL, PL/SQL</title><link>https://cyevgeniy.github.io/orasqlru/sql/sets/</link><description>Recent content in Работа с множествами on Учебник Oracle SQL, PL/SQL</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://cyevgeniy.github.io/orasqlru/sql/sets/index.xml" rel="self" type="application/rss+xml"/><item><title>Объединение. UNION</title><link>https://cyevgeniy.github.io/orasqlru/sql/sets/unions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cyevgeniy.github.io/orasqlru/sql/sets/unions/</guid><description>Предположим, что у нас есть 2 таблицы - таблица учителей teachers и таблица учеников students:
create table teachers( id number primary key, first_name varchar2(50) not null, last_name varchar2(100) ); create table students( id number primary key, first_name varchar2(50) not null, last_name varchar2(100), group_id number ); insert into teachers values (1, 'Галина', 'Иванова'); insert into teachers values (2, 'Нина', 'Сидорова'); insert into teachers values (3, 'Евгения', 'Петрова'); insert into students values (1, 'Александр', 'Обломов', 1); insert into students values (2, 'Николай', 'Рудин', 2); insert into students values (3, 'Евгения', 'Петрова', 1); Перед нами стоит задача - нужно отобразить единым списком учителей и учеников.</description></item><item><title>Разница запросов. MINUS</title><link>https://cyevgeniy.github.io/orasqlru/sql/sets/minus/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cyevgeniy.github.io/orasqlru/sql/sets/minus/</guid><description>Подготовим тестовые данные:
create table cars( car_id number not null, car_model varchar2(100) not null, release_year number ); create table car_offers( car_model varchar2(100) not null, release_year number ); insert into cars values(1, 'Volkswagen passat', 1998); insert into cars values(2, 'Volkswagen passat', 1998); insert into cars values(3, 'Mersedes SL', 2010); insert into cars values(4, 'Lexus S300', 2005); insert into cars values(5, 'Mersedes SL', 2008); insert into car_offers values('Lexus S300', 2010); insert into car_offers values('Tesla', 2017); insert into car_offers values('Volkswagen passat', 1998); insert into car_offers values('Volkswagen passat', 2003); Посмотрим на данные в таблицах:</description></item><item><title>Пересечение запросов</title><link>https://cyevgeniy.github.io/orasqlru/sql/sets/intersect/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cyevgeniy.github.io/orasqlru/sql/sets/intersect/</guid><description>В качестве тестовых данных будем использовать таблицы из примера про разность запросов.
Для получения пересечения данных между двумя запросами используется оператор INTERSECT. Он возвращает уникальные строки, которые присутствуют как в первом, так и во втором запросе.
Ограничения при использовании INTERSECT такие же, как и при использовании UNION и MINUS:
Оба запроса должны возвращать одинаковое количество колонок Типы данных в колонках должны совпадать. Получим список моделей автомобилей, которые есть и в автопарке, и в списке предлагаемых для покупки моделей:</description></item><item><title>Работа с множествами. Общая информация</title><link>https://cyevgeniy.github.io/orasqlru/sql/sets/sets/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cyevgeniy.github.io/orasqlru/sql/sets/sets/</guid><description>Следить за порядком колонок При использовании операторов UNION, MINUS и INTERSECT нужно внимательно следить за порядком колонок в каждом из запросов, ведь несоблюдение порядка следования приведет к некорректным результатам.
Как было рассмотрено, Oracle будет проверять, чтобы тип колонок в каждом из запросов совпадал, но проверять, правильно ли расположены колонки одного типа, он не будет (потому что не сможет).
select car_model model, car_id release_year from cars minus select car_model, release_year from car_offers В запросе выше, в первой его части, вместо колонки release_year по ошибке была указана колонка car_id.</description></item></channel></rss>