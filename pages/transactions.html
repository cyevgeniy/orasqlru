<!--{
    "Title": "Транзакции в Oracle",
    "Links": {
        "Prev": {
            "Url": "../pseudocolumns/index.html",
            "Title": "Псевдостолбцы"
        }
        }
}-->

<div class="doc-head mb-4 container-10">
    <h5 class="heading-micro heading-muted">Транзакции</h5>
    <h1 class="heading-huge heading-heavy">Транзакции в Oracle</h1>
</div>

<div class="doc-toc mt-6 mb-6">
    <nav class="menu menu-underline menu-medium menu-numbered">
        <ul class="menu-list">
        <li class="menu-item"><a href="#whatistransaction" class="menu-link">Что такое транзакции </a></li>
        <li class="menu-item"><a href="#commitrollback" class="menu-link">COMMIT. ROLLBACK</a></li>
        <li class="menu-item"><a href="#multiuser" class="menu-link"> Транзакции в многопользовательской среде</a></li>
        <li class="menu-item"><a href="#summary" class="menu-link"> Итого </a></li>
        </ul>
    </nav>
</div>

<h2 id="whatistransaction"> Что такое транзакции </h2>

<p>
Транзакции - это набор изменений данных, хранящихся в БД,
который должен быть либо выполнен, либо отменен. До сих
пор все примеры учебника, которые изменяли данные, как правило
состояли из одного запроса, и все наши транзакции состояли из одного
запроса. Если вы пользовались сервисом LiveSql, как мы рекомендовали,
то беспокоиться о транзакциях не следовало.
На самом деле, о них можно было не беспокоиться и в том случае, если
примеры запускались для локально установленной БД Oracle, просто
все изменения после закрытия соединения не были применены.
Но в реальности изменения в данных
часто представляют собой набор из нескольких запросов, и их
результаты чаще всего нужно фиксировать.
</p>

<p>
Чтобы было понятнее, рассмотрим такой процесс, как копирование
файлов. Предположим, какое-то количество файлов мы копируем
на флешку или жесткий диск. Когда половина файлов уже была
скопирована, возникла ошибка(любого рода - например, не хватило
места на диске), или пользователь передумал и отменил
операцию копирования. В этот момент копирование файлов прекращается,
но те файлы, которые уже были скопированы, останутся на флешке/диске.
Наша операция не была завершена, но состояние нашей системы
не такое же, каким оно было до начала копирования.
</p>

<p>
Так вот, если бы копирование файлов было транзакцией,
то после ее отмены, флешка/диск, на который мы копировали
файлы, не содержала бы ни одного из копируемых файлов.
А в том случае, если бы копирование прошло без прерываний,
то все файлы, наоборот, гарантированно бы присутствовали
в устройстве-получателе.
</p>

<p>
Рассмотрим такой процесс, как продажа автомобиля.
Распишем, какие действия должны производиться при
продаже:
</p>

<ol>
<li>Количество доступных автомобилей должно уменьшиться на 1</li>
<li>Должен быть составлен договор купли/продажи</li>
<li>Мы должны сохранить информацию о том, кто продал автомобиль,
чтобы учесть это при начислении премии сотрудникам</li>
</ol>

<p>
Очевидно, что данный процесс должен быть произведен
одной транзакцией, то есть все пункты этого
процесса должны быть произведены, либо, в случае ошибки,
или нашего собственного решения, ни одно из
этих действий не возымело эффект. В противном случае,
мы бы могли столкнуться с ситуацией, когда количество
проданных машин не совпадает с количеством договоров купли-продажи
(при условии, что на один автомобиль оформляется по одному договору),
или наоборот, количество договоров о продаже авто больше, чем количество
отсутствующих автомобилей, и так далее.</p>

<h2 id="commitrollback"> COMMIT. ROLLBACK </h2>

<p>В Oracle транзакция начинается с того момента, как 
БД получает первый DML запрос и заканчивается
либо закреплением транзакции, либо откатом всех изменений,
произведенных в ней.</p>

<p>Транзакция продажи автомобиля может выглядеть подобным образом:</p>

<pre>
-- Уменьшаем количество автомобилей
update cars c
set c.count = c.count - 1
where c.id = 132;

-- Создаем договор
insert into orders(car_id, customer_name)
values(132, 'Иван Петров');

-- Сохраняем информацию о консультанте, продавшем авто
insert into consult_wrk(employee_name, car_id)
values('Петя Иванов', 132);
</pre>

<p>Вместе с первым запросом начинается транзакция. Все последующие
запросы будут относиться к этой транзакции. Теперь главное - 
чтобы завершить транзакцию применением всех изменений, мы
должны вызвать команду <code>COMMIT</code>, а чтобы отменить все
изменения - вызывать команду <code>ROLLBACK</code>.</p>

<h3> Почему до сих пор нигде в учебнике не использовались commit/rollback? </h3>

<p>
Как было сказано, Oracle начинает транзакцию при получении первого
запроса, а точнее, первого запроса после предыдущей транзакции.
Во многих IDE для коммита или отката транзакции предусмотрены
отдельные элементы интерфейса - это могут быть кнопки, пункты меню
и т.д. Конечно, завершить или откатить транзакцию можно и непосредственно
вызовом <code>commit</code> или <code>rollback.</code>
</p>

<p>
Если примеры из учебника запускались в LiveSql, то там нет необходимости
делать коммиты или роллбэки, т.к. мы работаем с временной базой, и если
мы зайдем на этот сервис через час, нам заново придется создавать таблицы
и добавлять туда данные.
</p>

<p>
В том случае, если Oracle ставился локально, нужно было делать коммит,
чтобы изменения, произведенные при запуске dml запросов остались в базе.
</p>

<p>
Больше о транзакциях будет рассказано при рассмотрении языка
программирования PL/SQL, где будет подробнее рассмотрено, когда
и кто должен отправлять БД команды 
<code>COMMIT</code> и <code>ROLLBACK</code>.
</p>

<h2 id="multiuser"> Транзакции в многопользовательской среде </h2>

<p>База данных редко работает только с одним клиентом.
Чаще всего БД отвечает на запросы от большого числа
клиентов, и многие их этих запросов приходят к ней
в одно и то же время. Что будет, если во время выполнения
нашей транзакции, описанной выше, другой клиент выполнит
следующий запрос:</p>

<pre>
-- Получить количество договоров в системе
select count(*)
from orders
</pre>

<p>Ответ будет зависеть лишь от того, как была завершена
транзакция. Если она была завершена вызовом <code>COMMIT</code>, то
запрос вернет количество с учетом того договора, который был нами
создан, а если транзакция завершилась вызовом <code>ROLLBACK</code>,
либо вообще еще не завершилась(запросы еще выполняются, либо
они выполнились, но ни <code>ROLLBACK</code>, ни <code>COMMIT</code> не
вызывались), то новый договор не будет учтен в общем количестве,
т.к. другие сессии еще знают о существовании нового договора.
</p>

<div class="alert alert-info">
<p>
Здесь нужно сделать уточнение. Даже если наша транзакция будет
завершена вызовом <code>COMMIT</code>, запрос у другого клиента не будет брать
в расчет изменения, произведенные нашей транзакцией, если
наша транзакция была завершена позднее, чем запрос в другой
сессии начал свое выполнение.
</p>
</div>

<h2 id="summary"> Итого </h2>

<p>
Все изменения в БД производятся в пределах транзакций.
Транзакция может состоять как из одного запроса, так и из
нескольких.
</p>

<p>
<code>Commit</code> фиксирует изменения в базе данных,
<code>rollback</code> - отменяет.
</p>

<pre>
-- Обновляем признак активности пользователя
-- ADMIN
update users u
set u.is_active = 'N'
where u.user_name = 'ADMIN';

-- Фиксируем транзакцию. Изменения сохраняются в БД
commit;

-- Теперь опять меняем флаг is_active на значение
-- 'N'. Т.к. изменения, произведенные предыдущим
-- запросом, были зафиксированы, этот запрос
-- начинает новую транзакцию.
update users u
set u.is_active = 'Y'
where u.user_name = 'ADMIN';

-- У пользователя ADMIN флаг is_active
-- по-прежнему равен 'N', т.к. действие
-- транзакции было отменено вызовом
-- rollback
rollback;
</pre>


<p>
Транзакции могут состоять из набора изменений:
</p>

<pre>
-- Уменьшаем количество автомобилей
update cars c
set c.count = c.count - 1
where c.id = 132;

-- Создаем договор
insert into orders(car_id, customer_name)
values(132, 'Иван Петров');

-- Сохраняем информацию о консультанте, продавшем авто
insert into consult_wrk(employee_name, car_id)
values('Петя Иванов', 132);

-- Изменения, произведенные тремя запросами, будут
-- сохранены в базе данных
commit;
</pre>