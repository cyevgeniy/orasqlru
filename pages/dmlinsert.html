<!--{
    "Title": "Оператор INSERT",
    "Links": {
        "Next": {
            "Url": "../dmlupdate/index.html",
            "Title": "Изменение данных. UPDATE"
        },
        "Prev": {
            "Url": "../analytics/index.html",
            "Title": "Aналитические функции"
        }
        }
}-->

<div class="doc-head mb-4 container-10">
    <h5 class="heading-micro heading-muted">DML. Изменение данных и структуры БД</h5>
    <h1 class="heading-huge heading-heavy">Оператор INSERT </h1>
</div>

<div class="doc-toc mt-6 mb-6">
    <nav class="menu menu-underline menu-medium menu-numbered">
        <ul class="menu-list">
        <li class="menu-item"><a href="#withcolumns" class="menu-link">Вставка с указанием колонок</a></li>
        <li class="menu-item"><a href="#withoutcolumns" class="menu-link">Вставка без указания колонок</a></li>
        <li class="menu-item"><a href="#insertintoselect" class="menu-link">INSERT INTO ... SELECT</a></li>
        </ul>
    </nav>
</div>

<p>
Как уже говорилось ранее, <code>INSERT</code> предназначен для вставки данных
в таблицу. Существует несколько вариантов его использования.
</p>

<h2 id="withcolumns">Вставка с указанием колонок</h2>

<p>
В таком варианте после указания таблицы в скобках перечисляются колонки,
в которые будут записываться указываемые данные.
</p>


<pre>
insert into employees(id, name, age)
values(1, 'John', 35)
</pre>


<p>
Данный способ является предпочтительным, т.к. он более информативен - сразу
видно, что за данные вставляются в таблицу.
</p>

<p>
Также, при использовании такого способа, можно изменять порядок
перечисления данных для строки:
</p>


<pre>
insert into employees(age, name, id)
values(30, 'Dave', 2)
</pre>


<h2 id="withoutcolumns">Вставка без указания колонок</h2>

<p>
При таком варианте список столбцов таблицы не перечисляется, а сразу
указываются значения, которые вставляются в таблицу:
</p>


<pre>
insert into employees
values(1, 'John', 35)
</pre>


<p>
Такой способ подразумевает, что мы будем перечислять значения для всех
колонок в таблице, причем в том порядке, в котором они следуют в таблице.
</p>

<p>
Такой способ лучше не использовать, т.к. он:
</p>

<ul>
<li>Неинформативен. Невозможно сказать, что 
значит 1, а что 35 без просмотра
структуры таблицы</li>
<li>Нестабилен к изменениям. Добавление/удаление колонки из таблицы потребует
добавления/удаления значения из запроса.</li>
</ul>

<p>
Разберем последний минус данного подхода. Предположим, что в таблице
<code>employees</code> колонка <code>age</code> необязательна,
т.е. может содержать <code>NULL</code>.
</p>

<p>
В случае, когда мы указываем колонки, мы можем сделать так:
</p>

<pre>
insert into employees(id, name)
values(1, 'John')
</pre>


<p>
Если использовать вариант без указания колонок, то мы будем вынуждены
прописывать значения для всех колонок:
</p>


<pre>
insert into employees(id, name, age)
values(1, 'John', null)
</pre>


<p>
Попытка указать всего 2 значения при вставке приведет к ошибке
<code>ORA-00947: not enough values</code>:
</p>

<pre>
-- выдаст ошибку ORA-00947: not enough values
insert into employees
values(1, 'John')
</pre>


<p>
То же самое будет и в случае, если мы добавим в таблицу необязательную
колонку - написанный ранее запрос с перечислением колонок будет работать,
а запрос, в котором колонки не указывались - нет.
</p>

<h2 id="insertintoselect">INSERT INTO ... SELECT</h2>

<p>
Данный способ очень мощная и гибкая возможность. Она позволяет
использовать значения, возвращаемые оператором <code>select</code> в качестве значений
для вставки.
</p>

<p>
В общем виде подобный запрос выглядит так:
</p>

<pre>
insert into table_1(column_1, column_2, column_3...)
select col_1,
       col_2,
       col_3,
       ....
from table_2
</pre>


<p>
Более конкретный пример может выглядеть так: предположим, что нас попросили
записать в таблицу <code>emp_report</code> список сотрудников, которые старше 40 лет.
Из этой таблицы потом экспортируют данные в отчет для руководства.
</p>

<pre>
insert into emp_report(emp_id, name)
select emp.id,
       emp.name
from employees emp
where emp.age > 40
</pre>


<p>
В случае, если запрос <code>select</code> не вернул никаких данных,
то в таблицу также не будет вставлено ни одной строки.
</p>

<p>
В следующем примере данные не будут добавлены в таблицу(предполагается,
что в таблице <code>employees</code> нет сотрудников с отрицательным возрастом):
</p>

<pre>
insert into emp_report(emp_id, name)
select emp.id,
       emp.name
from employees emp
where emp.age < 0
</pre>


<p>
Запрос, получающий данные, может быть достаточно сложным - в нем могут
использоваться соединения таблиц, различные условия, подзапросы и т.п.
</p>

<p>
Предположим, нас попросили добавить также и количество детей у сотрудника.
Список детей по сотрудникам хранится в таблице <code>emp_childs</code>. Тогда запрос
вставки данных мог выглядеть следующим образом:
</p>

<pre>
insert into emp_report(emp_id, name, childs_count)
select emp.id,
       emp.name,
       count(chlds.id) childs_count
from employees emp
join emp_childs chlds on chlds.emp_id = emp.id
where emp.age > 40
group by emp.id, emp.name
</pre>

