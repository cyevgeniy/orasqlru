<!--{
    "Title": "Функции для работы со строками",
    "Links": {
        "Next": {
            "Url": "../nullfunctions/index.html",
            "Title": "Функции для работы с NULL"
        },
        "Prev": {
            "Url": "../sets/index.html",
            "Title": "Работа с множествами. Общая информация"
        }
        }
}-->

<div class="doc-head mb-4 container-10">
    <h5 class="heading-micro heading-muted">Стандарные функции</h5>
    <h1 class="heading-huge heading-heavy">Функции для работы со строками</h1>
</div>

<div class="doc-toc mt-6 mb-6">
    <nav class="menu menu-underline menu-medium menu-numbered">
        <ul class="menu-list">
        <li class="menu-item"><a href="#upperlower" class="menu-link"><code>UPPER</code>, <code>LOWER</code></a></li>
        <li class="menu-item"><a href="#concatenation" class="menu-link">Конкатенация строк</a></li>
        <li class="menu-item"><a href="#substr" class="menu-link">Поиск подстроки</a></li>
        <li class="menu-item"><a href="#like" class="menu-link">Подобие строк. Like</a></li>
        <li class="menu-item"><a href="#initcap" class="menu-link">Приведение к верхнему регистру. INITCAP</a></li>
        <li class="menu-item"><a href="#replace" class="menu-link">Замена подстроки. REPLACE</a></li>
        <li class="menu-item"><a href="#trim" class="menu-link">Удаление пробелов. TRIM</a></li>
        <li class="menu-item"><a href="#lpadrpad" class="menu-link">LPAD, RPAD</a></li>
        </ul>
    </nav>
</div>


<p>
Создадим тестовую таблицу.
</p>

<pre>
create table articles(
    title varchar2(50) not null,
    author varchar2(50) not null,
    msg varchar2(300) not null,
    publish_date date not null
);

comment on table articles is 'Твиты';
comment on column articles.title is 'Заголовок';
comment on column articles.author is 'Автор';
comment on column articles.msg is 'Сообщение';

insert into articles values ('Новый фотоаппарат!', 'johndoe',
    'Сегодня купил себе новый фотоаппарат. Надеюсь, у меня будут получаться отличные фотографии!', sysdate);
insert into articles values ('Насобирал денег', 'johndoe',
    'Целый год я шел к этой цели, и вот наконец-то у меня все получилось, и заветная сумма собрана!', sysdate - 1);
insert into articles values ('Задался целью', 'johndoe',
    'Итак, я задался целью купить себе фотоаппарат. Для начала нужно насобирать денег на него.', sysdate - 2);
insert into articles values ('Сходил в ресторан!', 'user003',
    'Пришел из ресторана. Еда была просто восхитительна!', sysdate - 3);
insert into articles values ('Съездили в отпуск!', 'artem69',
    'Наконец-то выбрались с женой и детьми в отпуск, было замечательно!', sysdate - 4);
</pre>

<p>
Таблица <code>articles</code> представляет собой место хранения сообщений пользователей, что-то вроде twitter.
</p>



<h2 id="upperlower">UPPER, LOWER</h2>

<p>
Данные функции уже описывались раньше.
</p>

<ul>
<li><code>UPPER</code>: приводит строку к верхнему регистру</li>
<li><code>LOWER</code>: приводит строку к нижнему регистру</li>
</ul>

<p>
Рекомендуется использовать одну из этих функций,
если нужно сравнить две строки между
собой без учета регистра символов.
</p>

<h2 id="concatenation">Конкатенация строк</h2>

<p>
Конкатенация - это "склейка" строк. Т.е., если у нас есть 2 строки -
"Новый", "фотоаппарат", то результатом конкатенации будет строка "Новый фотоаппарат".
</p>

<p>
Для склейки строк в Oracle используется оператор <code>||</code>.
</p>

<pre>
select 'Автор:' || art.author frmt_author,
       'Заголовок:"' || art.title  || '"' frmt_title
from articles art
</pre>

<img src="../../img/4_strings/str_concat.png">

<h2 id="substr">Поиск подстроки</h2>

<p>
Для того, чтобы найти вхождение одной строки в другую, используется
функция <code>INSTR</code>. Она возвращает позицию
вхождения одной строки в другую. Если вхождения
не обнаружено, то в качестве результата будет возвращён 0.
</p>

<p>
Следующий запрос возвращает позицию, начиная
с которой в заголовках записей пользователей
встречается символ восклицательного знака:
</p>

<pre>
select a.title,
       instr(a.title, '!') pos
from articles a
</pre>


<img src="../../img/4_strings/instr_!.png">

<p>
Как видно, для тех заголовков, которые не содержат восклицательный знак, функция <code>INSTR</code> вернула 0.
</p>

<p>
В функции <code>INSTR</code> можно задавать позицию,
начиная с которой следует производить поиск вхождения:
</p>

<pre>
select a.title,
       instr(a.title, 'о', 3) pos
from articles a
</pre>


<img src="../../img/4_strings/instr_o.png">

<p>
Данный запрос вернет позицию буквы о в заголовках
записей, но поиск будет производить лишь
начиная с 3-го символа заголовка.
</p>

<p>
Так, в строке "Новый фотоаппарат" мы получили результат
8, хотя буква о есть и раньше - на второй позиции.
</p>

<p>
В качестве стартовой позиции поиска можно указывать отрицательное
число. В этом случае функция отсчитает от конца строки
указанное количество символов и будет производить поиск начиная
от этой позиции и заканчивая началом строки:
</p>

<pre>
select a.title,
       instr(a.title, 'а', -4) pos
from articles a
</pre>

<img src="../../img/4_strings/instr_4a.png">

<p>
Также можно указать, какое по счету совпадение нужно искать(4-ый параметр в функции <code>INSTR</code>):
</p>

<pre>
select a.title,
       instr(a.title, 'о', 1, 2) pos
from articles a
</pre>

<img src="../../img/4_strings/instr_o1_2.png">

<h2 id="like">Подобие строк. Like</h2>

<p>
Для рассмотрения этой темы будем использовать данные из части про
<a href="../orderby/index.html">сортировку</a>.
</p>

<p>
Предположим, нам понадобилось посмотреть, какие чаи есть у
нас в меню. В данном примере единственный способ, которым
мы можем определить, что блюдо является чаем - это
проверить, содержится ли слово чай в наименовании.
</p>

<p>
Но оператор сравнения здесь не подойдет, так
как он вернет лишь те строки, которые
будут полностью совпадать со строкой Чай.
</p>

<p>
Перед рассмотрением примера добавим в таблицу меню немного чайных блюд:
</p>

<pre>
insert into dishes(name, price, rating) values ('Зеленый чай', 1, 100);
insert into dishes(name, price, rating) values ('Чай%', 2, 100);
insert into dishes(name, price, rating) values ('Чай+', 1, 200);
insert into dishes(name, price, rating) values ('Чай!', 1, 666);
</pre>

<p>
Гениальные маркетологи решили, что будут добавлять по одному
символу в конце слова чай для обозначения его крепости -
"чай%" - совсем слабенький, "чай+" взбодрит с утра, а с "чаем!" можно забыть про
сон на ближайшие сутки. Не будем задумываться, почему именно
так, а просто примем это как есть.
</p>

<p>
Итак, первый пример использования <code>LIKE</code>:
</p>

<pre>
select d.*
from dishes d
where d.name like 'Чай%'
</pre>

<img src="../../img/3_select/like_tea_percent.png">

<p>
Как видно, были получены все блюда, наименования которых начиналось с
последовательности символов, составляющей слово Чай. Символ "%" в условии
<code>LIKE</code> соответствует любой последовательности символов. Т.е.
предыдущий запрос можно было читать так: "Получить все блюда, первые
символы наименований которых составляют слово Чай, а после этих символов
следует последовательность из любых символов в любом количестве, мне
не важно". Кстати, в результат не попал зеленый чай - первые 3
символа наименования у него равны "Зел", но никак не "Чай".
</p>

<p>
Если не указывать символ "%", то запрос не вернет никаких данных:
</p>

<pre>
select d.*
from dishes d
where d.name like 'Чай'
</pre>


<img src="../../img/3_select/no_data_found.png">

<p>
При задании шаблонов в LIKE можно использовать следующие символы соответствия:
</p>

<ul>
<li>"%"(знак процента). Ему соответствует 0 или больше символов в значении.</li>
<li>"_"(нижнее подчеркивание). Ему соответствует ровно один символ в значении.</li>
</ul>

<p>
Получим все чаи, названия которых придумали
маркетологи(а это любой 1 символ после слова
"чай"):
</p>

<pre>
select d.*
from dishes d
where d.name like ('Чай_')
</pre>

<img src="../../img/3_select/like_tea_.png">

<p>
Также, как и при обычном сравнении, учитывается регистр строк.
Следующий запрос не вернет никаких данных, т.к. нет блюд, начинающихся со строки
"чай", есть только блюда, начинающиеся на "Чай"(первая буква заглавная):
</p>

<pre>
select d.*
from dishes d
where d.name like ('чай%')
</pre>

<img src="../../img/3_select/no_data_found.png">

<p>
Получим только зеленый чай:
</p>

<pre>
select d.*
from dishes d
where d.name like ('%чай')
</pre>

<img src="../../img/3_select/like_percent_tea.png">

<p>
Здесь символ процента был перемещен перед словом "чай",
что означает: "Любая последовательность символов(или их отсутствие), заканчивающаяся словом чай".
</p>

<p>
А для того, чтобы получить список всех блюд, в наименовании
которых содержится слово "чай", можно написать следующий запрос:
</p>

<pre>
select d.*
from dishes d
where upper(d.name) like upper('%чай%')
</pre>

<img src="../../img/3_select/like_percent_tea_percent.png">

<h3>Выражение ESCAPE в LIKE</h3>

<p>
Перед рассмотрением выражения опять добавим немного данных в таблицу <code>dishes</code>:
</p>

<pre>
insert into dishes values ('Кофе(0.4% кофеина)', 30, 20);
insert into dishes values ('Кофе(0.3% кофеина)', 30, 20);
insert into dishes values ('Кофе(0.1% кофеина)', 30, 20);
insert into dishes values ('Кофе(без кофеина)', 30, 20);
</pre>

<p>
Перед нами стоит задача: получить список кофейных блюд, содержащих кофеин.
</p>

<p>
Можно выделить некоторый список признаков, по которым мы сможем определить,
что кофе с кофеином:
</p>

<ul>
<li>Наименование начинается со слова "Кофе"</li>
<li>Если кофе с кофеином, то в скобках указывается
его процентное содержание в виде
"n% кофеина", где n - некоторое число.</li>
</ul>

<p>
На основании этих заключений можно написать следующий запрос:
</p>

<pre>
select d.*
from dishes d
where d.name like ('Кофе%кофеина')
</pre>

<img src="../../img/3_select/no_data_found.png">

<p>
В чем проблема, должно быть понятно - в том, что символ
"%" в условии <code>LIKE</code> обозначает совпадение с 0 или больше любых символов.
</p>

<p>
Для того, чтобы учитывать непосредственно символ
"%" в строке, условие <code>LIKE</code> немного видоизменяется:
</p>

<pre>
select d.*
from dishes d
where d.name like ('Кофе%\% кофеина%') escape '\'
</pre>

<img src="../../img/3_select/cofee_with_cofein.png">

<p>
Здесь после ключевого слова escape мы указываем символ,
который будет экранирующим, т.е. если перед символами<code>%</code> будет
стоять символ <code>\</code>, то он будет рассматриваться
как совпадение с одним символом <code>%</code>, а не как совпадение
0 и больше любых символов.
</p>

<h2 id="initcap">Приведение к верхнему регистру. INITCAP</h2>

<p>
Функция <code>INITCAP</code> делает первую букву каждого слова заглавной,
оставляя остальную часть слова в нижнем регистре.
</p>

<pre>
select initcap(art.author)
from articles art
</pre>

<img src="../../img/4_strings/author_initcap.png">

<pre>
select initcap(art.msg) msg_initcap
from articles art
</pre>


<img src="../../img/4_strings/msg_initcap.png">

<div class="alert alert-info">
<p>
Если строка состоит из нескольких слов, то в каждом
из этих слов первая буква будет заглавной,
а остальные - прописными.
</p>
</div>


<h2 id="replace">Замена подстроки. REPLACE</h2>

<p>
Для замены подстроки в строке используется функция <code>REPLACE</code>.
Данная функция принимает 3 параметра, из них последний - не обязательный:
</p>


<pre>
replace(исходная_строка, что_меняем, на_что_меняем)
</pre>


<p>
В случае, если не указать, на какую строку производить замену,
то совпадения будут просто уделены из исходной строки.
</p>

<p>
Например, получим все "твиты" пользователя
johndoe, но в заголовке поста заменим слово
"фотоаппарат" заменим на слово "мыльница":
</p>


<pre>
select replace(a.title, 'фотоаппарат', 'мыльница') new_title,
       a.msg
from articles a
where a.author = 'johndoe'
</pre>


<img src="../../img/4_strings/replace_photo.png">

<h2 id="trim">Удаление пробелов. TRIM</h2>

<p>
Есть 3 основных функции для удаления "лишних" пробелов из строки:
</p>

<ul>
<li><code>trim</code> - удалить пробелы вначале и в конце строки</li>
<li><code>ltrim</code> - удалить пробелы вначале строки (слева)</li>
<li><code>rtrim</code> - удалить пробелы в конце строки (справа)</li>
</ul>

<pre>
select trim('    John Doe      ') from dual;
select rtrim('    John Doe     ') from dual;
select ltrim('    John Doe    ') from dual;
-- То же самое, что и trim
select ltrim(rtrim('     John Doe    ')) from dual;
</pre>


<h2 id="lpadrpad">LPAD, RPAD</h2>

<p>
Эти функции используются, чтобы дополнить строку
какими-либо символами до определенной длины.
</p>

<p>
<code>LPAD</code> (left padding) используется для дополнения строки символами слева,
а <code>RPAD</code> (right padding) - для дополнения справа.
</p>

<pre>
select lpad('1', 5, '0') n1,
       lpad('10', 5, '0') n2,
       lpad('some_str', 10) n2_1,
       rpad('38', 5, '0') n3,
       rpad('3', 5, '0') n4
from dual
</pre>


<img src="../../img/4_strings/lpad_rpad.png">


<p>
Первый параметр в этой функции - строка, которую нужно дополнить,
второй - длина строки, которую мы хотим получить, а третий - символы, которыми
будем дополнять строку. Третий параметр не обязателен, и если его не указывать,
то строка будет дополняться пробелами, как в колонке <code>n2_1</code>.
</p>