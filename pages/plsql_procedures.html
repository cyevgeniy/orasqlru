<!--{
    "Title": "Процедуры в PL/SQL",
    "Links": {
        "Prev": {
            "Url": "../plsql_functions/index.html",
            "Title": "Функции в PL/SQL"
        }
        }
}-->

<div class="doc-head mb-4 container-10">
    <h5 class="heading-micro heading-muted">Основы PL/SQL</h5>
    <h1 class="heading-huge heading-heavy">Процедуры в PL/SQL </h1>
</div>

<div class="doc-toc mt-6 mb-6">
    <nav class="menu menu-underline menu-medium menu-numbered">
        <ul class="menu-list">
        <li class="menu-item"><a href="#simpleproc" class="menu-link">Пример создания простой процедуры </a></li>
        <li class="menu-item"><a href="#diffs" class="menu-link">Общепринятые различия между функциями и процедурами</a></li>
        <li class="menu-item"><a href="#inout" class="menu-link">IN, OUT, IN OUT параметры</a></li>
        <li class="menu-item"><a href="#deleteproc" class="menu-link">Удаление процедуры</a></li>
        </ul>
    </nav>
</div>

<h2 id="simpleproc"> Пример создания простой процедуры </h2>

<pre>
create or replace procedure validate_age(
    page number
)
is
begin
    if page < 18 then
        dbms_output.put_line('Вам должно быть 18 или больше');
    else
        dbms_output.put_line('Всё хорошо');
    end if;
end;
</pre>

<p>
Вызовем процедуру c несколькими параметрами:
</p>

<pre>
begin
    validate_age(17);
    validate_age(40);
end;
/
</pre>

<p>
Вывод:
</p>

<pre>
Вам должно быть 18 или больше
Всё хорошо
</pre>

<p>
Как видно, особых отличий от создания функций нет. Основное отличие - 
процедуры не возвращают значений в таком виде, как это делают функции
(через вызов <code>return</code>).
</p>

<h2 id="diffs"> Общепринятые различия между функциями и процедурами </h2>

<p>
См. <a href="../plsql_schema/index.html#procvsfunc">Различия между функциями и процедурами </a>
</p>


<h2 id="inout"> IN, OUT, IN OUT параметры </h2>

<p>
Каждый параметр функции или процедуры может иметь
модификатор, отвечающий за характер данного параметра:
</p>

<ul>
    <li><code>IN</code>- входной параметр</li>
    <li><code>OUT</code>- выходной параметр</li>
    <li><code>IN OUT</code>- входной и выходной параметр</li>
</ul>

<p>
По умолчанию все параметры являются входными, так что явно указывать
<code>IN</code> необязательно. Такие параметры нельзя изменять
в теле процедуры или функции.
</p>

<p>
<code>OUT</code>-параметры, наоборот, предназначены для того, чтобы быть измененными.
Часто их используют в процедурах для того, чтобы вернуть некоторое
значение(или даже несколько значений).
</p>

<pre>
create or replace procedure get_const_values(
    min_date out date,
    max_date out date,
    default_date out date
)
is
begin
    min_date := to_date('1800-01-01', 'yyyy-mm-dd');
    max_date := to_date('4021-01-01', 'yyyy-mm-dd');
    default_date := sysdate;
end;
/
</pre>

<p>
После этого выполним следующий код:
</p>

<pre>
declare
    l_min_date date;
    l_max_date date;
    l_default_date date;
begin
    get_const_values(l_min_date, l_max_date, l_default_date);

    dbms_output.put_line(l_min_date);
    dbms_output.put_line(l_max_date);
    dbms_output.put_line(l_default_date);
end;
/
</pre>

<p> Вывод: </p>

<pre>
01-JAN-00
01-JAN-21
05-DEC-21
</pre>


<p>
OUT параметры не могут иметь значений по умолчанию:
</p>

<pre>
create or replace procedure get_const_values(
    min_date out date := to_date('1800-01-01', 'yyyy-mm-dd'),
    max_date out date := to_date('4021-01-01', 'yyyy-mm-dd')
)
is
begin
    null;
end;
/
</pre>

<p>
В результате функция будет создана с ошибкой
<code>OUT and IN OUT formal parameters may not have default expressions</code>.
</p>

<div class="alert alert-info">
<p>
Как определять ошибки при создании хранимых процедур, будет
рассказано в отдельной части.
</p>
</div>

<p>
<code>IN OUT</code> параметры доступны для чтения внутри хранимой процедуры, но в 
то же время они доступны и для изменения.
</p>


<pre>
create or replace procedure get_const_values(
    min_date in out date,
    max_date in out date 
)
is
begin
    -- Читаем значения переменных
    dbms_output.put_line(min_date);
    dbms_output.put_line(min_date);

    -- Изменяем значения переменных
    min_date := to_date('3000-02-02', 'yyyy-mm-dd');
    max_date := to_date('3001-02-02', 'yyyy-mm-dd');

end;
/
</pre>

<p>
Запустим эту процедуру и выведем на экран
значение переменных после её выполнения:
</p>

<pre>
declare
    l_min date := to_date('1900.01.01', 'yyyy-mm-dd');
    l_max date := to_date('1900.01.01', 'yyyy-mm-dd');
begin
    get_const_values(l_min, l_max);

    dbms_output.put_line(l_min);
    dbms_output.put_line(l_max);
end;
/
</pre>

<p> Вывод: </p>

<pre>
01-JAN-00
01-JAN-00
02-FEB-00
02-FEB-01
</pre>

<p>
Как можно заметить, значения переменных были изменены после
вызова процедуры.
</p>

<p>
Важной особенностью <code>OUT</code> и <code>IN OUT</code> параметров является то,
что они должны быть переданы в виде переменных, задать их
значения литералом нельзя:
</p>

<pre>
create or replace procedure myproc(
    page out number
)
is
begin
    dbms_output.put_line(page);
end;
/
</pre>
<p>
И теперь попробуем вызвать процедуру, используя
литерал, а не переменную:
</p>

<pre>
begin
    myproc(12);
end;
/
</pre>

<p>
В результате получим ошибку <code>expression '12' cannot be used as an assignment target</code>.
</p>

<h2 id="deleteproc"> Удаление процедуры </h2>

<p>
Чтобы удалить процедуру из схемы, используется команда <code>drop procedure</code>:
</p>

<pre>
drop procedure myproc;
</pre>


