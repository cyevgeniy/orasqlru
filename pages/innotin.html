<!--{
    "Title": "IN, NOT IN",
    "Links": {
        "Next": {
            "Url": "../between/index.html",
            "Title": "Вхождение в диапазон. BETWEEN. NOT BETWEEN"
        },
        "Prev": {
            "Url": "../isnull/index.html",
            "Title": "Проверка значения на NULL"
        }
        }
}-->

<div class="doc-head mb-4 container-10">
    <h5 class="heading-micro heading-muted">Основы</h5>
    <h1 class="heading-huge heading-heavy">IN, NOT IN </h1>
</div>

<div class="doc-toc mt-6 mb-6">
    <nav class="menu menu-underline menu-medium menu-numbered">
        <ul class="menu-list">
        <li class="menu-item"><a href="#in" class="menu-link">Вхождение в набор данных. IN</a></li>
        <li class="menu-item"><a href="#notin" class="menu-link">Отсутствие в наборе данных. NOT IN</a></li>
        </ul>
    </nav>
</div>


<h2 id="in">Вхождение в набор данных. IN</h2>

<p>
Условие <code>IN</code> позволяет ответить на следующий вопрос:
"Входит ( IN ) ли значение в заданный набор данных?".
</p>

<p>
Следующий пример вернет все блюда, рейтинг которых равен 320 либо 270:
</p>

<pre>
select d.*
from dishes d
where d.rating IN (320, 270)
</pre>


<img src="../../img/3_select/rating_in_320_270.png">

<p>
Использовать можно любые типы, не только числа:
</p>

<pre>
select d.*
from dishes d
where d.name IN 
    ('Макароны с сыром', 'Овощной салат', 'Борщ')
</pre>


<img src="../../img/3_select/dishes_name_in.png">

<p>
Следует помнить, что при сравнении строк учитывается регистр, т.е. cледующий запрос:
</p>

<pre>
select d.*
from dishes d
where d.name IN
    ('Макароны с сыром', 'ОВОЩНОЙ салат', 'БОРЩ')
</pre>


<p>
Не вернет строки с овощным салатом и борщом:
</p>

<img src="../../img/3_select/name_in_casesensitive.png">

<p>
Можно попробовать поправить ситуацию и воспользоваться уже знакомой
функцией <code>UPPER</code>. Напомним, что эта функция приводит строку к верхнему регистру:
</p>


<pre>
select d.*
from dishes d
where UPPER(d.name) IN
    ('Макароны с сыром', 'ОВОЩНОЙ салат', 'БОРЩ')
</pre>


<img src="../../img/3_select/name_in_upper_borsch.png">

<p>
Итак, следующим запросом мы фактически сказали БД: "Покажи нам все строки из таблицы dishes,
в которых наименование, написанное большими буквами, будет равно
либо "Макароны с сыром", либо "ОВОЩНОЙ салат", либо "БОРЩ".
</p>

<p>
Почему в выборку не попали макароны с сыром и овощной салат? Ответ прост - строка "МАКАРОНЫ С СЫРОМ"
не идентична строке "Макароны с сыром", как и строка "ОВОЩНОЙ САЛАТ" не идентична строке "ОВОЩНОЙ салат".
</p>

<p>
Как же можно получить все три интересующих нас блюда,
не переживая за то, что регистры строк(а здесь достаточно несовпадения
и хотя бы в одном символе) в таблице <code>dishes</code> не совпадут
с регистрами строк, которые мы перечисляем в выражении <code>IN</code>?
</p>

<p>
Ответ прост - привести к верхнему/нижнему регистру как строки в таблице, так и строки в выражении <code>IN</code>.
</p>

<p>
Следующий запрос выдаст список всех интересующих нас блюд:
</p>

<pre>
select d.*
from dishes d
where UPPER(d.name) IN (
    upper('Макароны с сыром'),
    upper('ОВОЩНОЙ салат'),
    upper('БОРЩ')
)
</pre>


<img src="../../img/3_select/dishes_name_in.png">

<h2 id="notin">Отсутствие в наборе данных. NOT IN</h2>

<p>
Условие <code>NOT IN</code> выполняет функцию, противоположную выражению <code>IN</code>:
убедиться, что значение не входит в указанный набор данных.
</p>

<p>
Например, нам требуется получить список блюд, за исключением чая с молоком и овощного салата:
</p>

<pre>
select *
from dishes
where name not in ('Овощной салат', 'Чай с молоком')
</pre>


<p>
Получим следующий результат:
</p>

<img src="../../img/3_select/not_in_tea_s.png">

<p>
Для понимания того, как работает конструкция NOT IN, лучше рассматривать
приведенный пример как следующий, эквивалентный запрос:
</p>

<pre>
select *
from dishes
where name <> 'Овощной салат'
and name <> 'Чай с молоком'
</pre>

<p>
При использовании <code>NOT IN</code>, проверяемое значение будет поочередно
сравнено с каждым из значений, перечисленных в скобках после <code>NOT IN</code>, и
если хотя бы одно сравнение не будет истинным, то все условие будет считаться ложным.
</p>

<p>
Если в списке значений <code>NOT IN</code> будет присутствовать хотя бы одно <code>NULL</code>-значение,
то условие будет ложным для всех обрабатываемых строк, даже тех,
где проверяемое значение является <code>NULL</code>.
</p>


<p>
Для большего понимания рассмотрим это на примере.
</p>

<p>
Предположим, мы хотим получить список блюд, рейтинг которых
не 320 и не NULL. Для этого мы написали следующий запрос:
</p>


<pre>
select *
from dishes
where rating not in (320, null)
</pre>


<img src="../../img/3_select/no_data_found.png">

<p>
Результат получился немного не таким, как хотелось бы. Для того, чтобы понять,
почему не было получено никаких данных, следует понимать, как рассматривается данный запрос:
</p>

<pre>
select *
from dishes
where rating <> 320
and rating <> null
</pre>


<p>
Теперь все должно быть более понятным. Причина кроется в выражении
<code>rating <> null</code>. Как уже было рассмотрено, сравнение с <code>NULL</code>
всегда дает ложный результат, а так как используется логическое И(and),
то и результат всего выражения WHERE будет ложным.
</p>

<p>
Поэтому, используя <code>NOT IN</code>, всегда следует убедиться в отсутствии null-значений.
</p>
