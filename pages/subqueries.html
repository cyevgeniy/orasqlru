<!--{
    "Title": "Подзапросы в Oracle",
    "Links": {
        "Next": {
            "Url": "../unions/index.html",
            "Title": "Объединение. UNION."
        },
        "Prev": {
            "Url": "../recursive/index.html",
            "Title": "Рекурсивные запросы"
        }
        }
}-->

<div class="doc-head mb-4 container-10">
    <h5 class="heading-micro heading-muted">Основы</h5>
    <h1 class="heading-huge heading-heavy">Подзапросы в Oracle </h1>
</div>

<div class="doc-toc mt-6 mb-6">
    <nav class="menu menu-underline menu-medium menu-numbered">
        <ul class="menu-list">
        <li class="menu-item"><a href="#prepare" class="menu-link">Подготовка тестовых данных</a></li>
        <li class="menu-item"><a href="#subinwhere" class="menu-link">Подзапросы в where- части запроса</a></li>
        <li class="menu-item"><a href="#subinselect" class="menu-link">Подзапросы в select-части</a></li>
        <li class="menu-item"><a href="#subinfrom" class="menu-link">Подзапросы во FROM части </a></li>
        <li class="menu-item"><a href="#correlated" class="menu-link">Коррелированные подзапросы</a></li>
        <li class="menu-item"><a href="#subinnotin" class="menu-link">Подзапросы в IN, NOT IN</a></li>
        </ul>
    </nav>
</div>

<p>
Подзапросы представляют собой обычные SQL-запросы, которые
являются частью другого SQL-запроса.
</p>

<p>
Подзапросы - важная часть в изучении SQL.
Некоторые данные просто не могут быть получены, если их
не использовать. Далее будут рассмотрены примеры использования подзапросов в Oracle.
</p>

<h2 id="prepare">Подготовка тестовых данных</h2>

<pre>
create table books(
    book_id number primary key,
    book_name varchar2(200) not null,
    author varchar2(50 char) not null,
    release_year number not null
);

create table book_orders(
    book_id number not null,
    quantity number(2) not null,
    order_date date not null
);


comment on table books is 'Книги';
comment on table book_orders is 'Статистика продаж за день';


insert into books
values(1, 'Властелин колец', 'Толкин', 1954);

insert into books
values(2, 'Гордость и предубеждение', 'Джейн Остин', 1813);

insert into books
values(3, 'Тёмные начала', 'Филип Пулман', 1995);

insert into books
values(4, 'Автостопом по галактике', 'Дуглас Адамс', 1979);

insert into book_orders
values(1, 1, to_date('31.12.2005', 'dd.mm.yyyy'));

insert into book_orders
values(1, 4, to_date('30.12.2005', 'dd.mm.yyyy'));

insert into book_orders
values(2, 2, to_date('10.05.2005', 'dd.mm.yyyy'));

insert into book_orders
values(2, 1, to_date('12.05.2005', 'dd.mm.yyyy'));

insert into book_orders
values(3, 2, to_date('05.11.2005', 'dd.mm.yyyy'));
</pre>


<h2 id="subinwhere">Подзапросы в where- части запроса</h2>

<p>
Получим информацию о продажах книги "Властелин колец":
</p>


<pre>
select bo.*
from book_orders bo
where bo.book_id = (
    select book_id
    from books
    where book_name = 'Властелин колец'
);
</pre>


<img src="../../img/8_subqueries/wherepart_1.png">

<p>
Здесь использовался подзапрос, чтобы определить id
книги с названием "Властелин колец".
</p>

<p>
Если выполнить подзапрос отдельно:
</p>

<pre>
select book_id
from books
where book_name = 'Властелин колец'
</pre>


<p>
То мы получим одну строку, которая будет
содержать значение <code>book_id</code>, равое 1.
Поэтому самый первый запрос эквивалентен следующему:
</p>


<pre>
select bo.*
from book_orders bo
where bo.book_id = 1
</pre>

<p>
Следует обратить внимание на то, что в данном случае
подзапрос должен возвращать только одну строку,
состоящую из одной колонки. Следующие запросы работать не будут:
</p>

<pre>
select bo.*
from book_orders bo
where bo.book_id = (
	select book_id,
               book_name
        from books
        where book_name = 'Властелин колец'
)
</pre>


<p>
Данный запрос выдаст ошибку <code>ORA-00913: too many values</code>,
т.к. подзапрос возвращает одну строку с двумя колонками.
</p>

<pre>
select bo.*
from book_orders bo
where bo.book_id = (select book_id from books)
</pre>

<p>
А здесь будет ошибка <code>ORA-01427: single-row subquery returns more than one row</code>,
что переводится как "однострочный подзапрос возвращает более одной строки".
Из-за этого результат выполнения данного подзапроса нельзя
подставить в условие сравнения, т.к. сравнение должно работать
с одиночными значениями.
</p>

<h2 id="subinselect">Подзапросы в select-части</h2>

<p>
Подзапросы, которые возвращают одиночные значения, можно использовать
прямо в части <code>SELECT</code> в качестве колонок.
Результат выполнения подзапроса будет добавляться к
каждой строке, как обычная колонка:
</p>

<pre>
select b.*,
       (select count(*) from book_orders) ord_cnt
from books b
</pre>


<img src="../../img/8_subqueries/selectpart_1.png">

<p>
Здесь мы добавили колонку <code>ord_cnt</code>, которая содержит
количество всех имеющихся заказов по всем книгам.
</p>

<p>
Здесь также нельзя, чтобы запрос возвращал несколько
колонок или несколько строк. Зато запрос может ничего
не возвращать, тогда значение в колонке будет <code>NULL</code>:
</p>

<pre>
select b.*,
       (select book_id from book_orders where 2 > 10) book_id_subq
from books b
</pre>

<img src="../../img/8_subqueries/selectpart_2.png">

<p>
Т.к. утверждение <code>2 > 10</code> ложно, подзапрос не вернет
ни одной записи, поэтому значение в соответствующей колонке будет <code>NULL</code>.
</p>

<h2 id="subinfrom">Подзапросы во FROM части</h2>

<p>
Подзапросы можно использовать во FROM части запроса, и обращаться к данным,
которые они возвращают, как с полноценной таблицей(в пределах запроса;
каким-либо образом удалить или изменить данные в подрапросе не получится).
</p>

<pre>
select b_orders.*
from (
select b.book_id, b.book_name, bo.quantity, bo.order_date
from books b
join book_orders bo on bo.book_id = b.book_id) b_orders
where b_orders.quantity > 1
</pre>


<img src="../../img/8_subqueries/frompart_1.png">

<p>
Здесь мы написали отдельный запрос, дали ему псевдоним <code>b_orders</code>, поместили
его во <code>FROM</code> часть, как будто это обычная таблица, и дальше работаем с
псевдонимом данного подзапроса.
</p>

<p>
В подзапросе использовались <a href="../joins/index.html"> соединения</a>.
</p>

<p>
Сам подзапрос можно выполнить отдельно:
</p>

<pre>
select b.book_id, b.book_name, bo.quantity, bo.order_date
from books b
join book_orders bo on bo.book_id = b.book_id
</pre>

<img src="../../img/8_subqueries/frompart_2.png">

<p>
Как можно заметить, там есть строки, в которых количество(столбец <code>quantity</code>)
равен 1.
</p>

<p>
Но в первом примере этих строк нет, т.к. мы прописали условие
<code>where b_orders.quantity > 1</code>.
</p>

<p>
Подзапросов во <code>FROM</code> части может быть несколько, т.е. мы можем соединять
их, как обычные таблицы(опять, про соединения таблиц можно почитать
<a href="../joins/index.html"> вот здесь</a>.
</p>

<p>
В отличие от подзапросов, которые используются в select-части, данные
подзапросы могут возвращать более одной строки (более того, как правило,
они и возвращают много строк, иначе зачем их использовать?).
</p>

<h2 id="correlated">Коррелированные подзапросы</h2>

<p>
Коррелированный подзапрос - это такой подзапрос, который
использует для своей работы данные из внешнего по отношению
к нему запроса. Например:
</p>

<pre>
select b.*,
       (select count(*)
        from book_orders
        where book_id = b.book_id) ord_cnt
from books b
</pre>


<img src="../../img/8_subqueries/correlated_select.png">

<p>
Здесь подзапрос подсчитывает количество дней, в которые
производились продажи определенной книги.
Т.е. подзапрос считает количество строк в таблице
<code>book_orders</code> по значению колонки <code>book_id</code>,
которую он берет из внешнего запроса.
В условии прописывается <code>where book_id = b.book_id</code>,
что означает: "Возьми для каждой строки из основного
запроса значение колонки book_id, и посчитай
количество строк в таблице book_orders с таким же book_id."
</p>

<h2 id="subinnotin">Подзапросы в IN, NOT IN</h2>

<p>
Ранее уже рассматривались примеры и особенности использования
<code>IN</code> и <code>NOT IN</code> в SQL. В качестве перечисляемых значений
в этих операторах были значения, которые прописывал сам программист.
На практике чаще всего в качестве источника для значений
в этих операторах используются подзапросы:
</p>

<pre>
select b.*
from books b
where b.book_id in (
    select book_id
    from book_orders bo
    where bo.quantity < 2)
</pre>

<img src="../../img/8_subqueries/inpart_1.png">

<p>
Данный запрос выводит список книг, у которых были
продажи менее, чем по 2 штуки в день.
</p>

<p>
Cписок книг для оператора <code>IN</code> формируется
в результате выполнения подзапроса, а не ручного
кодирования значений программистом.
</p>

<p>
Подзапросы в <code>IN</code> и <code>NOT IN</code> должны возвращать строки
с одной колонкой.
Следующий запрос выдаст ошибку <code>ORA-00913: too many values</code>, т.к.
подзапрос получает список строк с двумя колонками:
</p>

<pre>
select b.*
from books b
where b.book_id in (
    select book_id, quantity
    from book_orders bo
    where bo.quantity < 2)
</pre>

<p>
При этом не следует забывать об особенности использования
<code>NOT IN</code>: Если в списке значений для проверки есть хотя
бы одно <code>NULL</code>-значение, то результат выражения будет ложным,
и запрос не вернет никаких данных:
</p>

<pre>
select b.*
from books b
where b.book_id  not in (
    select book_id
    from book_orders bo
    where bo.quantity < 2

    union

    select null
    from dual)
</pre>

<img src="../../img/3_select/no_data_found.png">

<p>
Здесь при помощи <a href="../unions/index.html">объединения</a> запросов в выборку
подзапроса была добавлена строка с одним <code>NULL</code>-значением, и
как следствие, запрос не вернул никаких данных.
</p>
