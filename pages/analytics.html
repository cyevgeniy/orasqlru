<!--{
    "Title": "Аналитические функции",
    "Links": {
        "Next": {
            "Url": "../dmlinsert/index.html",
            "Title": "Вставка данных. INSERT"
        },
        "Prev": {
            "Url": "../datafunctions/index.html",
            "Title": "Работа с датами в Oracle"
        }
        }
}-->

<div class="doc-head mb-4 container-10">
    <h5 class="heading-micro heading-muted">Стандарные функции</h5>
    <h1 class="heading-huge heading-heavy">Аналитические функции </h1>
</div>

<div class="doc-toc mt-6 mb-6">
    <nav class="menu menu-underline menu-medium menu-numbered">
        <ul class="menu-list">
        <li class="menu-item"><a href="#becomeanalytic" class="menu-link">Когда агрегирующая функция становится аналитической</a></li>
        <li class="menu-item"><a href="#partitionby" class="menu-link">Подсчет результатов по группам. Partition by</a></li>
        <li class="menu-item"><a href="#orderby" class="menu-link">Порядок вычисления. Order by</a></li>
        <li class="menu-item"><a href="#range" class="menu-link">Диапазон работы аналитических функций</a></li>
        <li class="menu-item"><a href="#rows" class="menu-link">Строки и значения</a></li>
        <li class="menu-item"><a href="#margins" class="menu-link">Смещения при определении окна</a></li>
        <li class="menu-item"><a href="#orderbylimitations" class="menu-link">Ограничения на ORDER BY</a></li>
        </ul>
    </nav>
</div>

<p>Аналитические функции - очень мощный
инструмент в SQL. Со слов Тома Кайта,
можно написать отдельную книгу по аналитическим
функциям, настолько они полезны.</p>

<p>Аналитические функции - это те же агрегирующие
функции, но их главная особенность в том, что
они работают без необходимости группировки строк.</p>

<p>Аналитические функции выполняются последними в запросе,
поэтому они могут быть использованы только в <code>SELECT</code> части
запроса, либо в <code>ORDER BY</code>.</p>

<p>Для примера возьмем данные, которые мы использовали
при разборе агрегирующих функций:</p>

<pre>
alter table employees
add (exp number);

merge into employees emp
using (select level lvl, rownum * 10 exp
       from dual
       connect by level <= 4) val
on (emp.id = val.lvl)
when matched then
    update
    set emp.exp = val.exp;
</pre>

<p>Посмотрим, какие данные теперь хранятся в таблице:</p>

<pre>
select *
from employees
</pre>

<img src="../../img/16_analytic/all_employees.png">

<p>Теперь напишем запрос, который
бы возвращал максимальный стаж среди всех сотрудников
отдельной колонкой. Для этого можно использовать подзапрос:</p>

<pre>
select id,
       first_name,
       last_name,
       (select max(exp) from employees) max_exp
from employees
</pre>

<img src="../../img/16_analytic/subq_max_exp.png">

<p>Усложним задачу: напишем запрос, который будет
возвращать отдельной колонкой максимальный стаж
на должности каждого сотрудника. Для этого также
можно использовать подзапрос, только уже коррелированный:</p>

<pre>
select emp.first_name,
       emp.last_name,
       emp.job,
       (select max(exp) from employees where job = emp.job) max_exp
from employees emp
</pre>

<img src="../../img/16_analytic/subq_max_job.png">

<p>Теперь решим эти же задачи при помощи аналитический функций:</p>

<pre>
select emp.first_name,
       emp.last_name,
       emp.job,
       max(exp) over () max_exp
from employees emp
</pre>

<pre>
select emp.first_name,
       emp.last_name,
       emp.job,
       max(exp) over (partition by job) max_exp
from employees emp
</pre>

<p>Аналитические функции позволяют использовать агрегирующие
функции без подзапросов, что уменьшает размер запроса( примеры,
когда использование подзапроса усложняет чтение запроса,
будут немного дальше).</p>

<p>Помимо этого, вот еще два примера запросов с
аналитическими функциями.</p>

<pre>
select id,
       first_name,
       last_name,
       job,
       bd,
       exp,
       max(exp) over (order by first_name) max_exp_asc,
       max(exp) over (order by first_name desc) max_exp_desc
from employees emp
</pre>


<img src="../../img/16_analytic/analytics_min_max_exp.png">

<p>Две колонки, <code>max_exp_asc</code> и <code>max_exp_desc</code>,
считают максимальный стаж среди сотрудников в порядке
возрастания и убывания их имен соответственно.</p>

<p>С простыми примерами аналитических функций мы познакомились,
теперь разберемся,как они работают.</p>

<h2 id="becomeanalytic"> Когда агрегирующая функция становится аналитической </h2>

<p>В первом примере агрегирующая функция <code>max</code> превратилась
в аналитическую после добавления к ней части <code>over()</code>.
В итоге, было найдено максимальное значение колонки <code>exp</code>
среди всего набора данных, и это значение было добавлено
к каждой строке выборки, без группировки.</p>

<h2 id="partitionby"> Подсчет результатов по группам. Partition by </h2>

<p>Для того, чтобы результаты считались по определенным
группам, нужно использовать конструкцию <code>partition by</code>,
в которой нужно указать колонки, по которым будет
производиться вычисление.</p>

<pre>
select emp.first_name,
       emp.last_name,
       emp.job,
       max(exp) over (partition by job) max_exp
from employees emp
</pre>

<p>В данном примере, который уже приводился раньше, максимальный
стаж вычисляется в отдельности для каждой из профессий, и затем
добавляется к каждой строке.</p>

<p>Посчитаем количество сотрудников по должностям и выведем
отдельной колонкой:</p>

<pre>
select emp.first_name,
       emp.last_name,
       emp.job,
       count(*) over (partition by job) job_cnt
from employees emp
</pre>

<img src="../../img/16_analytic/job_cnt_analytics.png">

<p>Результаты можно считать по нескольким группам.
Выведем напротив каждого сотрудника общее число сотрудников,
родившихся в том же месяце(колонка <code>mnth_cnt</code>) и количество
сотрудников, родившихся в том же месяце и занимающих такую же
должность:</p>

<pre>
select emp.id,
       emp.first_name,
       emp.last_name,
       emp.job,
       emp.bd,
       count(*) over(
           partition by extract(month from emp.bd)
       ) mnth_cnt,
       count(*) over (
           partition by extract(month from emp.bd), job
       ) mnth_cnt
from employees emp
</pre>


<img src="../../img/16_analytic/partition_by_few.png">

<p>
Всего есть три сотрудника, которые родились в одном и том же месяце - июле.
Поэтому в колонке <code>mnth_cnt</code> отображается число 3.
В то же время, есть лишь два сотрудника, которые
родились в одном и том же месяце,
и при этом занимают одну и ту же должность
- это сотрудники с id равными 2 и 3.</p>

<h2 id="orderby"> Порядок вычисления. Order by </h2>

<p>В аналитических функциях можно указывать порядок, в котором они будут
работать с итоговым набором данных. Для этого используется конструкция
<code>order by</code>.</p>

<p>Пронумеруем строки в нашей таблице в порядке возрастания и убывания
дней рождения сотрудников.</p>

<pre>
select emp.id,
       emp.first_name,
       emp.last_name,
       emp.job,
       emp.bd,
       row_number() over (order by bd) bd_asc,
       row_number() over (order by bd desc) bd_desc
from employees emp
</pre>

<img src="../../img/16_analytic/order_by_1.png">

<p>Функция <code>row_number</code> возможно является одной из самых часто используемых
аналитических функций. Она возвращает номер строки в итоговой выборке. До
ее появления в Oracle подобного функционала можно было достичь лишь при использовании
подзапросов и псевдостолбца <code>ROWNUM</code>.</p>

Аналитические функции могут работать не только по группам или в определенном
порядке, но и в определенном порядке в пределах заданной группы:

<pre>
select emp.id,
       emp.first_name,
       emp.last_name,
       emp.job,
       emp.bd,
       row_number() over (
           partition by job order by bd
       ) bd_asc,
       row_number() over (
           partition by job order by bd desc
       ) bd_desc
from employees emp
</pre>

<img src="../../img/16_analytic/partitionby_orderby.png">

<p>Здесь нумерация производится отдельно для каждой группы.
У двух сотрудников с одинаковой должностью нумерация была
проставлена в порядке их дней рождения.</p>

<h2 id="range"> Диапазон работы аналитических функций </h2>

<p>Аналитические функции всегда, явно или неявно, применяются
к определенному набору строк, называемому окном аналитической
функции.</p>

<p>Не во всех аналитических функциях можно указывать окно.
Среди самых часто используемых функций, для которых можно указывать окно,
находятся  <code>MIN</code>, <code>MAX</code>, <code>SUM</code>, <code>AVG</code>, <code>COUNT</code>,
<code>LAST_VALUE</code>, <code>FIRST_VALUE</code> и другие.</p>

<p>Чтобы примеры были немного более практичными, создадим
еще одну таблицу, в которой будем хранить данные о начисленных
зарплатах сотрудникам по месяцам:</p>

<pre>
create table emp_salary(
    emp_id number not null,
    sal_date date not null,
    sal_value number not null,
    -- Начисления в данной таблице должны быть
    -- "сбитыми" по месяцам, и чтобы в данных не
    -- возникло ошибки, создаем уникальный ключ на
    -- поля с id сотрудника и месяцем начисления
    constraint emp_salary_uk unique(emp_id, sal_date)
);

comment on table emp_salary is
    'Зачисленные средства по месяцам';
comment on column emp_salary.emp_id is 
    'id сотрудника';
comment on column emp_salary.sal_date is 
    'Месяц начисления';
comment on column emp_salary.sal_value is 
    'Начисленные средства';

insert into emp_salary(emp_id, sal_date, sal_value)
values(1, to_date('01.01.2020', 'dd.mm.yyyy'), 1000);

insert into emp_salary(emp_id, sal_date, sal_value)
values(1, to_date('01.02.2020', 'dd.mm.yyyy'), 1320);

insert into emp_salary(emp_id, sal_date, sal_value)
values(1, to_date('01.03.2020', 'dd.mm.yyyy'), 850);


insert into emp_salary(emp_id, sal_date, sal_value)
values(2, to_date('01.01.2020', 'dd.mm.yyyy'), 1000);

insert into emp_salary(emp_id, sal_date, sal_value)
values(2, to_date('01.02.2020', 'dd.mm.yyyy'), 800);

insert into emp_salary(emp_id, sal_date, sal_value)
values(2, to_date('01.03.2020', 'dd.mm.yyyy'), 1200);


insert into emp_salary(emp_id, sal_date, sal_value)
values(3, to_date('01.01.2020', 'dd.mm.yyyy'), 1030);


insert into emp_salary(emp_id, sal_date, sal_value)
values(4, to_date('01.01.2020', 'dd.mm.yyyy'), 3700);
</pre>

<p>Общие данные выглядят следующим образом:</p>

<pre>
select e.first_name,
       e.last_name,
       e.job,
       es.sal_date,
       es.sal_value
from emp_salary es
join employees e on e.id = es.emp_id
</pre>

<img src="../../img/16_analytic/emp_sal.png">

<p>Теперь добавим колонку к выборке, которая
будет показывать, как изменялась минимальная заработная
плата сотрудников с течением времени.</p>

<pre>
select e.first_name,
       e.last_name,
       e.job,
       es.sal_date,
       es.sal_value,
       min(es.sal_value) over (
           order by sal_date
           rows between unbounded preceding and
               current row
       ) min
from emp_salary es
join employees e on e.id = es.emp_id
</pre>

<img src="../../img/16_analytic/unb_preceding_1.png">

<p>Сейчас может показаться, что результат, который получился в запросе
такой же, как если бы мы и не задавали размер окна. Действительно, для текущих
данных запрос без добавления лишних ключевых слов выдает такой же результат:</p>

<pre>
select e.first_name,
       e.last_name,
       e.job,
       es.sal_date,
       es.sal_value,
       sum(es.sal_value) over (order by sal_date) min
from emp_salary es
join employees e on e.id = es.emp_id
</pre>

<img src="../../img/16_analytic/unb_preceding_1.png">

<p>Чуть позже станет понятно, что это 2 совершенно разных запроса, а пока
разберем подробнее различные варианты указания окна в аналитических функциях.</p>

<h2 id="rows"> Строки и значения </h2>

<p>Строки, которые определяют окно работы аналитической функции,
можно указывать физически, т.е. сказать БД: "Для текущей строки
в выборке аналитическая функция должна обработать две строки перед
ней и три строки после нее"; или: "Для текущей строки в выборке
аналитическая функция должна обработать все строки начиная с текущей
и заканчивая всеми последующими строками".</p>

<p>Вторым возможным способом определения окна является определение не
по физическому расположению строки в выборке, а по значениям, которые
строки в себе содержат. Мысленно это можно произнести: "Для текущей
строки в выборке аналитическая функция должна обработать те строки,
в которых значение колонки А будет больше, чем значение в колонке А
текущей строки"; или: "Для текущей
строки в выборке аналитическая функция должна обработать те строки,
в которых значение колонки А будет в пределах от 10 до 20 включительно".</p>

<p>В первом случае, при указании физических строк, используется
ключевое слово <code>ROWS</code>, во втором случае, при указании строк
по их значениям, используется ключевое слово <code>RANGE</code>.</p>

<h2 id="margins"> Смещения при определении окна </h2>

<p>Итак, при указании окна мы должны задать его верхнюю и нижнюю границу.</p>

<p>В общем виде указание границы выглядит следующим образом:</p>

<pre>
(range или rows) between "Верхняя граница" and "Нижняя граница"
</pre>

<p>Теперь рассмотрим варианты для этих границ:</p>

<ul>
<li> <code>UNBOUNDED PRECEDING</code> - указывает, что окно начинается с первой строки
   в разделе. Может быть указано только для верхней границы, в качестве
   нижней границы использовать нельзя.</li>
<li> <code>UNBOUNDED FOLLOWING</code> - указывает, что окно заканчивается на последней
   строке в разделе. Может быть указано только для нижней границы.</li>
<li> <code>CURRENT ROW</code> - обозначает текущую строку или значение. Может быть использовано
  как для нижней границы, так и для верхней.</li>
<li> <code><значение>PRECEDING</code> - значение в строке или физическая строка, которая
  предшествует текущей строке на <значение></li>
<li> <code><значение>FOLLOWING</code> - значение в строке или физическая строка, которая
  находится впереди текущей строки на <значение></li>
</ul>

<p>Следует помнить, что если
окно задается с использованием <code>ROWS</code>, т.е. указываются строки,
то и границы окна будут задаваться в строках, и наоборот,
если используется <code.RANGE</code>, то границы окна будут учитываться
по значениям в строках.</p>

<p>Если окно не указывается, то по-умолчанию оно имеет вид
<code>RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW</code>.</p>

<p>Теперь посмотрим на один из предыдущих запросов:</p>

<pre>
select e.first_name,
       e.last_name,
       e.job,
       es.sal_date,
       es.sal_value,
       min(es.sal_value) over (
           order by sal_date
           rows between unbounded preceding
               and current row
       ) min
from emp_salary es
join employees e on e.id = es.emp_id
</pre>

<p>Рассмотрим, как будет работать аналитическая функция.</p>

<p><code>PARTITION BY</code> не указан, значит результаты будут "сплошные"
и не будут разбиваться по группам. Обрабатываться строки будут в
порядке возрастания даты в колонке
<code>sal_date</code>, а диапазон строк, для которых будет вычисляться
функция, задается первой строкой во всем наборе данных
и заканчивается текущей строкой.</p>

<p>Теперь должна быть понятна разница между данным запросом и запросом без
указания окна, о которой говорилось в начале раздела - по-умолчанию
окно задается по значению, а мы установили размер окна со смещениями в строках.</p>

<p>Еще один важный момент: значения в колонке <code>sal_date</code> не являются уникальными.
Это означает, что результат будет недетерминированным, т.е. может отличаться от запуска
к запуску, т.к. порядок следования строк в выборке может измениться.</p>

<p>Чтобы избавиться от такого эффекта, можно добавить еще одну колонку в конструкцию
order by, чтобы сделать порядок следования строк уникальным и не меняющимся. В данном
случае мы можем дополнительно сортировать данные по id сотрудника:</p>

<pre>
min(es.sal_value) over (
    order by sal_date, id
    rows between unbounded preceding 
        and current row
) min
</pre>

<p>В общем, когда несколько колонок имеют одинаковые значения,
аналитические функции работают по определенным правилам:</p>

<ul>
  <li> Функции <code>CUME_DIST</code>, <code>DENSE_RANK</code>, <code>NTILE</code>, <code>PERCENT_RANK</code> и
<code>RANK</code> возвращают одинаковый результат для всех строк</li>
 <li> Функция <code>ROW_NUMBER</code> присвоит каждой строке уникальное значение.
Порядок присваивания будет зависеть от порядка обработки
   строк БД, который мы не можем предугадать</li>
 <li> Все остальные функции будут работать по-разному в зависимости
   от спецификации окна.
   Если окно задавалось при помощи <code>RANGE</code>, то функция вернет одинаковое значение для
   всех строк. Если использовалось ключевое слово <code>ROWS</code>, то результат нельзя будет
   предугадать - он опять же будет зависеть от порядка обработки строк базой данных,
   который может отличаться для одного и того же набора данных от запуска к запуску.</li>
</ul>

<p>Размеры окна можно задавать в виде смещений:</p>

<pre>
select e.first_name,
       e.last_name,
       e.job,
       es.sal_date,
       es.sal_value,
       round(
           avg(es.sal_value)over (
               order by sal_date, id
               rows between 2 preceding and current row
           ),
       2) avg_sal
from emp_salary es
join employees e on e.id = es.emp_id
</pre>

<img src="../../img/16_analytic/rows_2_preceding_curr_row.png">

<p>Здесь в колонке avg_sal считается средняя заработная
плата по трем строкам - двум предшествующим и текущей.
Порядок следования, как мы помним, задается при помощи
ORDER BY, поэтому две предшествующие
строки - это строки, у которых значение в колонках sal_date
будет меньше либо равным значению в текущей строке.</p>

<p>Значение функции округляется до двух знаков после запятой
при помощи функции <code>round</code>.
Аналитическая функция берется в скобки полностью, начиная
от имени функции и заканчивая определением окна.
К значениям, полученным при помощи аналитических функций можно
применять другие функции или операторы - например,
можно было бы добавить 100 к среднему значению:</p>

<pre>
avg(es.sal_value)over (
    order by sal_date
    rows between 2 preceding and current row
) + 100 avg_sal
</pre>

<p>Или даже получить разность между значениями двух
аналитических функций:</p>

<pre>
max(es.sal_value)
    over (
        order by sal_date
        range between 1 preceding and current row
    ) -
min(es.sal_value)
    over (
        order by sal_date
        rows between 1 preceding and current row
    )
</pre>

<p>В следующем примере смещение задается не в строках, а в
диапазоне значений, которые содержит колонка sal_value:</p>

<pre>
select e.first_name,
       e.last_name,
       e.job,
       es.sal_date,
       es.sal_value,
       sum(es.sal_value) over (
           order by sal_value
           range between 1000 preceding and current row
       ) max_sal
from emp_salary es
join employees e on e.id = es.emp_id
</pre>

<img src="../../img/16_analytic/preceding_range_1.png">

<p>Т.к. использовался <code>RANGE</code>, то сумма рассчитывается для всех строк,
значение которых находится в диапазоне от 1000 до значения в текущей строке.</p>

<p>Еще раз, следует обратить внимание, что строки, которые находятся после текущей,
также обрабатываются функцией, если значение колонки sal_value
входит в заданный диапазон.
Это можно видеть на изображении выше, в строках, где значение sal_value
равно 1000 - для первой строки в сумму посчиталось и значение следующей.</p>

<p>Следующий пример считает сумму по четырем строкам - в окно входят
2 предшествующие строки, текущая строка и одна строка, следующая за текущей:</p>

<pre>
select e.first_name,
       e.last_name,
       e.job,
       es.sal_date,
       es.sal_value,
       sum(es.sal_value) over (
           order by sal_value
           rows between 2 preceding and 1 following
       ) sum_sal
from emp_salary es
join employees e on e.id = es.emp_id
</pre>

<img src="../../img/16_analytic/sum_rows_3.png">

<p>Т.к. окно задавалось с использованием <code>ROWS</code>, сумма считается
именно по строкам, а не по их значениям. Для первой строки в сумму
были взяты данные из нее самой и следующей,
т.к. предыдущих строк у нее нет. Для второй строки была лишь
одна предыдущая строка, а у последней не было следующей.</p>

<h2 id="orderbylimitations"> Ограничения на ORDER BY </h2>

<p>ORDER BY в аналитических функциях может использоваться только с одной
колонкой, за исплючением случаев,
когда используется <code>RANGE</code> и окно задается одним из следующих способов:</p>

<ul>

<li> <code>RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW</code></li>
<li> <code>RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING</code></li>
<li> <code>RANGE BETWEEN CURRENT ROW AND CURRENT ROW</code></li>
<li> <code>RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING</code></li>
</ul>
