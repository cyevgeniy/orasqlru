<!--{
    "Title": "Представления",
    "Links": {
        "Next": {
            "Url": "../indexes/index.html",
            "Title": "Индексы"
        },
        "Prev": {
            "Url": "../uniquekeys/index.html",
            "Title": "Уникальные ключи"
        }
        }
}-->

<div class="doc-head mb-4 container-10">
    <h5 class="heading-micro heading-muted">Объекты БД</h5>
    <h1 class="heading-huge heading-heavy">Представления</h1>
</div>

<div class="doc-toc mt-6 mb-6">
    <nav class="menu menu-underline menu-medium menu-numbered">
        <ul class="menu-list">
        <li class="menu-item"><a href="#whatisviews" class="menu-link">Что такое представления</a></li>
        <li class="menu-item"><a href="#createview" class="menu-link">Создание представлений</a></li>
        <li class="menu-item"><a href="#modifydata" class="menu-link">Изменение данных представления</a></li>
        </ul>
    </nav>
</div>


<h2 id="whatisviews"> Что такое представления </h2>

<p>
Представления(Views) - это такой объект в БД, который:
</p>

<ol>
<li>Выглядит как таблица</li>
<li>Внутри себя содержит SQL запрос, которым
   заменяется таблица при обращении к ней.</li>
</ol>
   
<p>
Во многом представления работают также, как и обычные таблицы.
В них можно(правда с определенными ограничениями) вставлять,
изменять и удалять данные.
</p>


<h2 id="createview">Создание представлений</h2>

<p>
Общий синтаксис создания представления следующий:
</p>

<pre>
create view viewname as
select ...
....
....;
</pre>


<p>
Т.е. для создания представления достаточно написать
запрос, который возвращать нужные данные.
</p>

<p>
Можно создавать представления с опцией <code>or replace</code>, 
тогда в том случае, если такое представление уже существует,
оно будет заменено на новое.
</p>

<pre>
create or replace view viewname as
select ...
....
...;
</pre>


<p>
Создадим таблицу с сотрудниками, должностями и подразделениями:
</p>

<pre>
create table employees(
    id number,
    emp_name varchar2(100 char),
    dept_id number,
    position_id number
);

create table departments(
    id number,
    dept_name varchar2(100)
);

create table positions(
    id number,
    position_name varchar2(100)
);

insert into departments values(1, 'IT');
insert into departments values(2, 'SALARY');

insert into positions values(1, 'MANAGER');
insert into positions values(2, 'CLERK');

insert into employees values(1, 'Иван Петров', 1, 1);
insert into employees values(2, 'Петр Иванов', 1, 2);
insert into employees values(3, 'Елизавета Сидорова', 2, 1);
insert into employees values(4, 'Алексей Иванов', 2, 2);
</pre>

<p>
Создадим представление <code>vemployees</code>, которое будет
выводить данные по сотрудникам в уже
"соединенном" виде:
</p>

<pre>
create view vemployees as
select e.id,
       e.emp_name,
       d.dept_name,
       p.position_name
from employees e
join departments d on d.id = e.dept_id
join positions p on p.id = e.position_id;

comment on table vemployees is 'сотрудники';
comment on column vemployees.id is 'id сотрудника';
comment on column vemployees.emp_name is 'имя сотрудника';
comment on column vemployees.dept_name is 'подразделение';
comment on column vemployees.position_name is 'должность';
</pre>

<p>
Следует обратить внимание на то, что представлениям и 
колонкам в них можно задавать комментарии как и обычным
таблицам.
</p>

<p>
Теперь, чтобы получить нужные нам данные, нам не нужно
заново писать запрос, достаточно сразу выбрать данные
из представления:
</p>

<pre>
select *
from vemployees
</pre>

<img src="../../img/14_views/vemployees.png">


<p>
При создании представлений можно использовать уже существующие
представления:
</p>

<pre>
create view vemployees_it as
select a.*
from vemployees a
where a.dept_name = 'IT';
</pre>


<p>
Следует с осторожностью использовать уже созданные представления
при создании других представлений. Может случиться так,
что написать новый запрос будет куда лучше, чем использовать
существующие, но не полностью подходящие.
</p>

<h3>Символ * при создании представлений</h3>

<p>
Когда при создании представления используется 
символ "*", то Oracle заменяет звездочку на
список столбцов. Это означает, что если в таблицу будет добавлена
новая колонка, то она не будет автоматически добавлена
в представление.
</p>

<p>
Это очень просто проверить:
</p>

<pre>
create table tst(
    n1 number,
    n2 number
);

insert into tst values(1, 2);

create view v_tst as
select *
from tst;
</pre>

<p>
Посмотрим, какие данные содержатся в представлении:
</p>

<pre>
select *
from v_tst
</pre>


<img src="../../img/14_views/view_asterics_1.png">

<p>
Теперь добавим в таблицу <code>tst</code> еще одну колонку(
изменение таблиц будет рассматриваться позже, сейчас
достаточно понимать, что данный запрос добавляет новую
колонку в таблицу):
</p>

<pre>
alter table tst
add (n3 number);
</pre>


<p>
Если сейчас получить все данные из представления, мы
увидим, что список колонок в ней не изменился:
</p>

<img src="../../img/14_views/view_asterics_1.png">

<p>
Чтобы добавить колонку "n3" в представление,
можно изменить его, добавив в список колонок нужную,
либо заново создать(с использованием <code>create or replace</code>):
</p>

<pre>
create or replace view v_tst as
select *
from tst
</pre>



<h2 id="modifydata">Изменение данных представления</h2>

<p>
Таблицы, которые используются в запросе представления, называются *базовыми таблицами*.
</p>

<p>
Представления, которые созданы на основании одной базовой таблицы, можно
изменять также, как и обычную таблицу.
</p>

<p>
Например, создадим представление <code>vdepartments</code> и добавим в него
несколько записей.
</p>

<pre>
-- создаем представление
create view vdepartments as
select id, dept_name
from departments;

-- добавляем данные через представление, а не таблицу
insert into vdepartments(id, dept_name)
values(10, 'SALES');
</pre>

<p>
Конечно, фактически данные добавляются не в представление,
а в базовую таблицу(в данном случае <code>departments</code>):
</p>

<pre>
select *
from departments
</pre>

<img src="../../img/14_views/departments_all.png">

<p>
Строки можно и удалять, а также и изменять:
</p>

<pre>
delete from vdepartments
where id = 10;

update vdepartments
set dept_name = 'SECURITY'
where id = 1;
</pre>

<p>
Посмотрим на результаты:
</p>

<pre>
select *
from vdepartments
</pre>


<img src="../../img/14_views/vdepartments.png">

<h3>Представления с проверкой (WITH CHECK OPTION)</h3>

<p>
Можно создавать представления, которые будут ограничивать
изменение данных в базовых таблицах. Для этого используется
опция <code>WITH CHECK OPTION</code> при создании представления.
</p>

<p>
Создадим представление, которое содержит в себе только
менеджеров:
</p>

<pre>
create view vemp_managers as
select *
from employees
where position_id = 1;
</pre>

<p>
Данное представление содержит только менеджеров, но это не означает,
что в него нельзя добавить сотрудников других профессий:
</p>

<pre>
-- Добавим сотрудника c position_id = 2
insert into vemp_managers(id, emp_name, dept_id, position_id)
values(10, 'Иван Иванов', 1, 2);
</pre>

<p>
Данные в представлении остались те же, что и были:
</p>


<pre>
select *
from vemp_managers
</pre>


<img src="../../img/14_views/vemp_managers.png">

<p>
А вот в таблицу <code>employees</code> был добавлен новый сотрудник
Иван Иванов:
</p>

<pre>
select *
from employees
where id = 10
</pre>


<img src="../../img/14_views/employees_id_10.png">

<p>
Для того, чтобы через представление можно было изменять
только те данные, которые в нем содержатся(а точнее,
которые можно получить через представление), при его
создании следует указать опцию <code>WITH CHECK OPTION</code>.
</p>

<p>
Создадим заново представление <code>vemp_managers</code>, только
с добавлением <code>with check option</code>, и попробуем снова
добавить в него запись:
</p>

<pre>
create or replace view vemp_managers as
select *
from employees
where position_id = 1
with check option;

-- Попробуем добавить запись с position_id = 2
insert into vemp_managers(id, emp_name, dept_id, position_id)
values(11, 'Иван Иванов Второй', 1, 2);
</pre>

<p>
При попытке это сделать, мы получим ошибку <code>view WITH CHECK OPTION where-clause violation</code>.
</p>

<p>
Но зато добавить сотрудника с <code>position_id = 1</code> можно без проблем:
</p>


<pre>
-- Запись успешно добавится в таблицу employees
insert into vemp_managers(id, emp_name, dept_id, position_id)
values(11, 'Иван Иванов Второй', 1, 1);
</pre>


<h3>Изменение представлений из нескольких таблиц</h3>

<p>
В Oracle можно изменять данные через представления,
которые получают данные из нескольких таблиц.
</p>

<p>
Но есть определенные ограничения:
</p>

<ol>
<li>Изменять можно данные только одной базовой таблицы</li>
<li>Изменяемая таблица должна быть т.н. "key preserved table"
(таблица с сохранением ключа).</li>
</ol>

<p>
Второй пункт возможно самый важный для понимания того,
можно ли изменять данные в представлении из нескольких
таблиц или нет.
</p>

<p>
Так вот, таблица называется key preserved, если каждой
ее строке соответствует *максимум одна строка* в представлении.
</p>

<div class="alert alert-info">
<p>
Следует помнить, что свойство сохранения ключа в представлениях
не зависит от данных, а скорее от структуры таблиц и их
отношений между собой. Фактически в представлении данные могут
выглядеть так, что для одной строки базовой таблицы есть лишь
одна строка представления, но это не означает, что этот
вид не изменится при изменении данных в таблицах представления.
</p>
</div>


<p>
Для примера создадим представление <code>vemp_depts</code>,
которое будет содержать информацию о сотрудниках и подразделениях,
в которых они работают:
</p>

<pre>
create or replace view vemp_depts as
select e.id,
       e.emp_name,
       e.dept_id,
       e.position_id,
       d.id department_id,
       d.dept_name
from employees e
join departments d on e.dept_id = d.id
</pre>

<p>
Посмотрим, какие данные там находятся:
</p>

<pre>
select *
from vemp_depts
</pre>


<img src="../../img/14_views/vemp_depts_1.png">

<p>
Как мы видим, каждая строка из базовой таблицы <code>employees</code>
встречается в представлении всего один раз. Попробуем добавить
нового сотрудника через это представление:
</p>

<pre>
insert into vemp_depts(id, emp_name, dept_id, position_id)
values(20, 'Иван Василенко', 1, 1);
</pre>


<p>
В результате получаем ошибку <code>cannot modify a column which maps to a non key-preserved table</code>,
которая говорит о том, что таблица не обладает нужными свойствами для обновления
через представление.
</p>

<p>
Зная, что проблему нужно искать не в самих данных, а в схеме БД, посмотрим, как мы
создавали наши таблицы и как выглядит наш запрос в представлении.
</p>

<pre>
select e.id,
       e.emp_name,
       e.dept_id,
       e.position_id,
       d.id department_id,
d.dept_name
from employees e
join departments d on e.dept_id = d.id
</pre>

<p>
Здесь мы берем каждую строку из таблицы <code>employees</code> и соединяем
с таблицей <code>departments</code> по полю <code>dept_id</code>. В каком случае может
произойти так, что в представлении для одной строки из таблицы
<code>employees</code> окажутся 2 строки после соединения с таблицей <code>departments</code>?
Правильно, в том случае, если в таблице <code>departments</code> будут 2 строки
с одинаковым значением в колонке <code>id</code>. Сейчас таких данных в таблице нет,
но это не означает, что они не могут появиться. Посмотрим, как мы создавали
таблицу <code>departments</code>:
</p>

<pre>
create table departments(
    id number,
	dept_name varchar2(100)
);
</pre>


<p>
Как видно, нет никаких ограничений на колонку <code>id</code>.
Но мы можем сделать ее уникальной, добавив <a href="../primarykeys/index.html">первичный</a> или 
<a href="../uniquekeys/index.html">уникальный ключ</a>.
</p>

<pre>
alter table departments
add (
    constraint departments_pk primary key(id)
);
</pre>


<p>
Теперь снова попробуем добавить нового сотрудника:
</p>

<pre>
-- Запись будет добавлена без ошибок
insert into vemp_depts(id, emp_name, dept_id, position_id)
values(20, 'Иван Василенко', 1, 1);
</pre>


<p>
Добавить данные в таблицу <code>departments</code> через это представление
не получится:
</p>

<pre>
--  cannot modify a column which maps to a non key-preserved table
insert into vemp_depts(department_id, dept_name)
values(7, 'HEAD DEPARTMENT');
</pre>


<p>
Причина здесь та же: нельзя гарантировать, что в таблице
<code>employees</code> каждый сотрудник имеет уникальное значение <code>dept_id</code>.
</p>

<h3>Ограничения в изменяемых представлениях</h3>

<p>
Изменения в представлениях возможны не всегда. Есть определенные условия,
при которых они запрещены:
</p>

<ol>
<li>Наличие в представлении агрегатных функций, конструкции <code>group by</code>,
   оператора <code>distinct</code>, операторов для работы с множествами(<code>union</code>,
   <code>union all</code>, <code>minus</code>).</li>
<li>Если данные не будут удовлетворять условию, прописанному в 
   опции <code>WITH CHECK OPTION</code>.</li>
<li>Если колонка в базовой таблице <code>NOT NULL</code>, не имеет значения
   по-умолчанию, и отсутствует в представлении.</li>
<li>Если колонки в представлении представляют собой выражения
   (Например что-то вроде <code>nvl(a.value, -1)</code>).</li>
</ol>

<h3>Запрет изменения представления</h3>

<p>
Чтобы создать представление, которое нельзя будет изменять,
нужно создать его с опцией <code>with read only</code>.
</p>

<p>
Пересоздадим представление <code>vdepartments</code> и попробуем добавить туда данные:
</p>

<pre>
create or replace view vdepartments as
select id, dept_name
from departments
with read only;

-- Попробуем добавить данные
insert into vdepartments(id, dept_name)
values(11, 'SECURITY');
</pre>

<p>
В результате получим ошибку <code>cannot perform a DML operation on a read-only view</code>.
</p>