<!--{
    "Title": "Объединение запросов. UNION",
    "Links": {
        "Next": {
            "Url": "../minus/index.html",
            "Title": "Разность. MINUS"
        },
        "Prev": {
            "Url": "../subqueries/index.html",
            "Title": "Подзапросы"
        }
        }
}-->

<div class="doc-head mb-4 container-10">
    <h5 class="heading-micro heading-muted">Работа с множествами</h5>
    <h1 class="heading-huge heading-heavy">Объединение запросов. UNION </h1>
</div>


<p>
Предположим, что у нас есть 2 таблицы - таблица
учителей <code>teachers</code> и таблица учеников <code>students</code>:
</p>

<pre>
create table teachers(
    id number primary key,
    first_name varchar2(50) not null,
    last_name varchar2(100)
);

create table students(
    id number primary key,
    first_name varchar2(50) not null,
    last_name varchar2(100),
    group_id number
);

    insert into teachers values (1, 'Галина', 'Иванова');
    insert into teachers values (2, 'Нина', 'Сидорова');
    insert into teachers values (3, 'Евгения', 'Петрова');

    insert into students values (1, 'Александр', 'Обломов', 1);
    insert into students values (2, 'Николай', 'Рудин', 2);
    insert into students values (3, 'Евгения', 'Петрова', 1);
</pre>

<p>
Перед нами стоит задача - нужно отобразить единым списком учителей и учеников.
</p>

<p>
Мы можем написать запрос для получения списка учителей:
</p>

<pre>
select first_name, last_name
from teachers
</pre>

<p>
Точно также можно получить список всех учеников:
</p>

<pre>
select first_name, last_name
from students
</pre>

<p>
Для того, чтобы эти данные "склеить", используется оператор <code>UNION</code>:
</p>

<pre>
select first_name, last_name
from teachers

union

select first_name, last_name
from students
</pre>

<img src="../../img/7_unions/union_example.png">

<p>
Если внимательно посмотреть на получившийся результат,
то можно заметить, что данных в "склеенной" выборке стало меньше.
</p>

<p>
Все дело в том, то оператор UNION удаляет дубликаты из итоговой выборки.
А так как у нас есть учитель "Евгения Петрова" и ученик
"Евгения Петрова", то при объединении оставляется только одна строка.
</p>

<p>
Для того, чтобы объединить данные из нескольких запросов без удаления
дубликатов, используется оператор <code>UNION ALL</code>:
</p>

<pre>
select first_name, last_name
from teachers

union all

select first_name, last_name
from students
</pre>

<p>
Если вы знаете, что в объединяемых данных не будет
повторяющихся строк, используйте <code>UNION ALL</code>.
В таком случае БД не будет тратить время на то,
чтобы убрать дубликаты из итоговой выборки.
</p>


<p>
Для того, чтобы <code>UNION</code> работал, должны соблюдаться некоторые условия:
</p>

<ul>
<li>Количество полей в каждой выборке должно быть одинаковым</li>
<li>Поля должны иметь одинаковый тип</li>
</ul>

<p>
То есть, следующий запрос вернет ошибку, т.к. в первой
части объединения запрос возвращает число первой колонкой, а второй - строку:
</p>


<pre>
select id, first_name
from teachers

union

select first_name, last_name
from students
</pre>

<p>
Результат - ошибка
<code>ORA-01790: expression must have same datatype as corresponding expression</code>.
</p>

<p>
Кстати, псевдонимы столбцов не обязательно должны совпадать у всех частей соединения:
</p>

<pre>
select first_name teacher_first_name, last_name teacher_last_name
from teachers

union

select first_name, last_name
from students
</pre>

<img src="../../img/7_unions/union_aliases.png">

<p>
Следует обратить внимание на то, что в результирующей
выборке псевдонимы для колонок взялись такие же, как
и в запросе из первой части объединения.
Если поменять эти части местами, то псевдонимы также изменятся:
</p>

<pre>

select first_name, last_name
from students

union

select first_name teacher_first_name, last_name teacher_last_name
from teachers
</pre>

<img src="../../img/7_unions/union_aliases_1.png">
