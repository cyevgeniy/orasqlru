<!--{
    "Title": "Первичные ключи",
    "Links": {
        "Next": {
            "Url": "../foreignkeys/index.html",
            "Title": "Внешние ключи"
        },
        "Prev": {
            "Url": "../ddlaltertable/index.html",
            "Title": "Изменение структуры таблиц. ALTER TABLE"
        }
        }
}-->

<div class="doc-head mb-4 container-10">
    <h5 class="heading-micro heading-muted">Объекты БД</h5>
    <h1 class="heading-huge heading-heavy">Первичные ключи</h1>
</div>

<div class="doc-toc mt-6 mb-6">
    <nav class="menu menu-underline menu-medium menu-numbered">
        <ul class="menu-list">
        <li class="menu-item"><a href="#createkey" class="menu-link">Добавление первичного ключа в таблицу</a></li>
        <li class="menu-item"><a href="#multiplecolumns" class="menu-link">Составные первичные ключи</a></li>
        </ul>
    </nav>
</div>


<p>
Рассмотрим следующую ситуацию: пусть у нас есть 2 таблицы.
Первая содержит список сотрудников, вторая - размер бонусов к зарплате
для какой-то части этих сотрудников.
</p>

<p>
В жизни есть определенная вероятность того, что двух разных людей могут
звать одинаково. Так вышло и у нас - 2 абсолютно разных сотрудника имеют
одинаковое имя - "Алексей Иванов".
</p>

<p>
Предположим, что мы хотим одному из них начислить бонус в размере 200$.
Глядя на список сотрудников с бонусами, можем ли мы сказать, какому
именно Алексею Иванову мы должны начислить бонус в размере 200$?
Однозначный ответ - нет.
</p>

<img src="../../img/13_relations/pk_problem.png">

<p>
Каждый отдельно взятый сотрудник - отдельная сущность, и всегда нужно
иметь возможность различать их между собой. Именно для этого и используются
первичные ключи.
</p>

<div class="alert alert-info">
<p>
Первичный ключ - это такой атрибут, который позволяет однозначно
идентифицировать отдельно взятую строку в таблице.
</p>
</div>

<p>
Исходя из этого можно выделить еще некоторые свойства первичного ключа:
</p>

<ol>
<li> Он не может быть пустым </li>
<li> Он уникален в пределах отдельно взятой таблицы</li>
<li>В таблице может быть только один первичный ключ</li>
</ol>


<h2 id="createkey">Добавление первичного ключа в таблицу</h2>

<p>
Добавить первичный ключ в таблицу можно несколькими способами. Первый -
добавление при создании таблицы:
</p>

<pre>
create table employees(
    id number primary key, -- Колонка id будет являться первичным ключом
    emp_name varchar2(100 char) not null,
    birth_date date not null
);
</pre>


<p>
Данный способ - самый простой. Мы просто добавляем к нужной колонке
<code>primary key</code>, и Oracle наделит ее всеми необходимыми свойствами.
</p>

<p>
Теперь давайте убедимся, что это действительно первичный ключ - попробуем
добавить 2 строки в таблицу с одинаковым значением колонки <code>id</code>:
</p>

<pre>
insert into employees(id, emp_name, birth_date)
values(1, 'Андрей Иванов', to_date('1984.12.04', 'yyyy.mm.dd'));

insert into employees(id, emp_name, birth_date)
values(1, 'Петр Иванов', to_date('1990.01.30', 'yyyy.mm.dd'));
</pre>


<p>
Первая строка вставится без ошибок, но при попытке добавить еще одну
с уже существующим <code>id</code> получим ошибку
<code>ORA-00001: unique constraint (SQL_PXTWBEIMXHBUXOWCVTDQXEQKK.SYS_C0029851757) violated ORA-06512</code>.
Эта ошибка говорит о том, что произошла попытка нарушить свойство уникальности
нашего ключа. Длинная строка в скобках - это название нашего ключа. При
создании его таким способом Oracle автоматически назначает каждому первичному
ключу уникальное имя. В таких небольших примерах нам легко понять, где
именно произошла ошибка, но в сложных системах с сотнями таблиц, с большим
количеством запросов на вставку в БД понять, на каком ключе происходит
сбой очень трудно.
</p>

<p>
К счастью, мы можем сами назначать имя для первичного ключа при создании
таблицы:
</p>

<pre>
create table employees(
    id number,
    emp_name varchar2(100 char) not null,
    birth_date date not null,
    constraint employees_PK primary key(id) -- создаем первичный ключ и назначаем ему имя
)
</pre>


<p>
Теперь попробуем вставить дублирующие значения в колонку <code>id</code>:
</p>

<pre>
insert into employees(id, emp_name, birth_date)
values(1, 'Андрей Иванов', to_date('1984.12.04', 'yyyy.mm.dd'));

insert into employees(id, emp_name, birth_date)
values(1, 'Петр Иванов', to_date('1990.01.30', 'yyyy.mm.dd'));
</pre>

<p>
На этот раз сообщение об ошибке будет немного другим:
<code>ORA-00001: unique constraint (SQL_EAIYWBGLYOEYCEZDANCUIWUWH.EMPLOYEES_PK) violated</code>.
Теперь мы явно видим, что ошибка в ключе <code>EMPLOYEES_PK</code>.
</p>

<h2 id="multiplecolumns">Составные первичные ключи</h2>

<p>
Первичный ключ может состоять из нескольких колонок. Подобный
ключ обладает теми же особенностями, что и ключ из одной колонки.
</p>

<p>
Рассмотрим примеры создания таблицы с составным первичным ключом.
</p>

<p>
Предположим, что мы хотим начислять дополнительные бонусы
сотрудникам каждый месяц. Одному сотруднику в месяц может
быть начислено не более одного бонуса. Данные в этой таблице
могли бы выглядеть вот так:
</p>

<pre>
|id сотрудника |месяц     |Размер бонуса
|1             |2020.01.01|300
|1             |2020.02.01|150
|2             |2020.02.01|240
|3             |2020.02.01|100
</pre>

<p>
Сделать колонку c id сотрудника первичным ключом нельзя,
т.к. в таком случае в таблице можно будет иметь лишь по
одной строке на каждого сотрудника. Но ключ из колонок
с id сотрудника и месяца бонуса отлично подойдет - 
на один месяц можно будет давать бонус только одному
сотруднику, в противном случае уникальность ключа
будет нарушена.
</p>

<pre>
create table month_bonuses(
    emp_id number not null,
    month_bonus date not null,
    bonus_value number not null,
    constraint month_bonuses_pk primary key(emp_id, month_bonus)
)
</pre>

<p>
Указать <code>primary key</code> напротив нескольких колонок нельзя,
т.к. Oracle будет пробовать каждую из этих колонок сдалеть
первичным ключом, а он может быть только один. В итоге мы
получим ошибку <code>ORA-02260: table can have only one primary key</code>:
</p>

<pre>
-- Получим ошибку при создании таблицы!
create table month_bonuses(
    emp_id number not null primary key,
    month_bonus date not null primary key,
    bonus_value number not null
)
</pre>

