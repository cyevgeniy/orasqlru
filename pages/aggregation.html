<!--{
    "Title": "Агрегирующие функции",
    "Links": {
        "Next": {
            "Url": "../datafunctions/index.html",
            "Title": "Работа с датами в Oracle"
        },
        "Prev": {
            "Url": "../bit/index.html",
            "Title": "Битовые операции"
        }
        }
}-->

<div class="doc-head mb-4 container-10">
    <h5 class="heading-micro heading-muted">Стандарные функции</h5>
    <h1 class="heading-huge heading-heavy">Агрегирующие функции</h1>
</div>

<div class="doc-toc mt-6 mb-6">
    <nav class="menu menu-underline menu-medium menu-numbered">
        <ul class="menu-list">
        <li class="menu-item"><a href="#prepare" class="menu-link">Тестовые данные</a></li>
        <li class="menu-item"><a href="#having" class="menu-link"><code>HAVING</code></a></li>
        </ul>
    </nav>
</div>


<p>Агрегирующие функции - это такие функции, которые выполняются
не для каждой строки отдельно, а для определенных групп данных.</p>

<h2 id="prepare"> Подготовка данных </h2>

<pre>
create table employees(
    id number not null,
    first_name varchar2(50 char) not null,
    last_name varchar2(100 char),
    bd date not null,
    job varchar2(100)
);

insert into employees
values(1, 'Василий', 'Петров',
    to_date('07.10.1990', 'dd.mm.yyyy'), 'Машинист');

insert into employees
values(2, 'Александр', 'Сидоров',
    to_date('18.07.1980', 'dd.mm.yyyy'), 'Бухгалтер');

insert into employees
values(3, 'Евгения', 'Цветочкина',
    to_date('18.07.1978', 'dd.mm.yyyy'), 'Бухгалтер');

insert into employees
values(4, 'Владимир', 'Столяров', 
    to_date('18.07.1977', 'dd.mm.yyyy'), 'Слесарь');
</pre>

<p>Например, следующий запрос найдет минимальную дату
рождения среди всех сотрудников:</p>

<pre>
select min(bd)
from employees
</pre>

<img src="../../img/9_aggregations/minbd.png">

<pre>
select min(bd) minbd, max(bd) maxbd
from employees
</pre>

<img src="../../img/9_aggregations/minbd_maxbd.png">

<p>Здесь также были добавлены псевдонимы
<code>minbd</code> и <code>maxbd</code> для колонок.</p>

<p>Агрегирующие функции могут быть использованы
в выражениях:</p>

<pre>
select min(bd) + 1 minbd,
       add_months(max(bd), 2) maxbd
from employees
</pre>

<img src="../../img/9_aggregations/minbd_maxbd_modified.png">

<p>Но получение одной-единственной даты мало что дает, хотелось
бы видеть больше данных, соответствующих минимальной или
максимальной дате в наборе данных.</p>

<pre>
select min(bd), max(bd), first_name
from employees
group by first_name
</pre>

<img src="../../img/9_aggregations/groupby_1.png">

<p>Если посмотреть на результат запроса, то все равно трудновато
понять, что дают в этом примере добавление имени
и группировка записей по нему. Для лучшего понимания
добавим в таблицу еще пару записей:</p>

<pre>
insert into employees
values(5, 'Евгения', 'Кукушкина',
    to_date('18.07.1989', 'dd.mm.yyyy'), 'Арт-директор');

insert into employees
values(6, 'Владимир', 'Кукушкин', 
    to_date('22.05.1959', 'dd.mm.yyyy'), 'Начальник департамента охраны');
</pre>

<p>Теперь выполним запрос еще раз:</p>

<pre>
select min(bd), max(bd), first_name
from employees
group by first_name
</pre>

<img src="../../img/9_aggregations/groupby_2.png">

<p>Теперь можно заметить несколько особенностей:</p>

<ul>
<li>Количество строк не изменилось </li>
<li>В строке с именем "Евгения" изменилась максимальная дата рождения</li>
<li> В строке с именем "Владимир" изменилась минимальная дата рождения</li>
</ul>

<p>
Видно, что агрегирующие функции могут применяться
не ко всему набору данных, а к определенным частям этого
набора. В данном случае группы были разбиты по именам,
т.е. 2 записи с именем "Евгения", 2 записи с именем
"Владимир", а остальные записи представляют собой
отдельные группы из одного элемента.</p>

<p>При этом следует обратить внимание, что несмотря на то,
что остальные колонки в строках с именем "Евгения" или "Владимир" отличаются
между собой, они все равно попадают в одну группу, т.к. группировка
производится только по имени.</p>

<h2 id="having"> Having </h2>

<p>Выведем список имен, которые встречаются более одного раза:</p>

<pre>
select first_name, count(*)
from employees
group by first_name
having count(*) > 1
</pre>

<img src="../../img/9_aggregations/having.png">

<p><code>Having</code> работает аналогично условию <code>where</code>,
 но только для значений агрегатных функций.</p>

